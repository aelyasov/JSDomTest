%% ------------------------------------------------------------------------
\section{Introduction}
\label{sec.intro}
%% ------------------------------------------------------------------------

According to the \emph{StackOverflow} Developer Survey 2018 \cite{stackoverflow2018}, JavaScript (JS) has been recognized for the sixth time in row as the most commonly used programming language. It is also the most popular language on \emph{GitHub}~\cite{guthub2017} based on the number of opened pull requests (2.3 million). The success of JS can be explained by its native browsers support, and the rise in popularity of the JS runtime environment \emph{Node.js}. On the other hand, JS applications are error-prone~\cite{frolin:TSE16} and challenging to test and analyze~\cite{mesbah2015advances,andreasen2017survey,sun2017analysis} due to such language features as implicit type conversion, lack of static types, and extensive support of dynamic constructs~\cite{richards2010analysis}. Thus, it is not surprising that once in a while critical bugs manage to make it into web applications of major companies such as Facebook, Twitter etc.~\cite{bugstories2017}.

Systematic unit testing is a basic and, at the same time, the most effective technique for improving software quality~\cite{martin2009clean}. There exist numerous JS frameworks on the market
--- Mocha, Jasmine, Jest, Enzyme, Tape, Ava, Karma, QUnit etc. ---
intended to assist web developers with the automation of various  activities such as the design, execution and monitoring of unit tests. Despite the apparent abundance of the JS testing tools, developers satisfaction  is still relatively low~\cite{stateJS2017} (3.2 out of 5), indicating there is a room for improvements. One of the missing steps on the way to complete JS test automation is \emph{the generation of test data}. It pursues the goal of maximizing test coverage by exercising the function under test (FUT) with various input parameters. Moreover, if a FUT interacts with the DOM of a web application, a \emph{test fixture} is expected as an additional input.

The problem of test data generation has been actively studied for the past three decades. In particular for JS, researchers have proposed several solutions based on: concolic execution (\emph{Jalangi}~\cite{sen2013jalangi}, \emph{Confix}~\cite{amin:ase15}), random generation (\mbox{\emph{JSContest}}~\cite{heidegger2010contract}), and the analysis of the complete web application (\emph{Artemis}~\cite{artemis2011}, Crawljax~\cite{mesbah2012crawling}). Out of those tools, only \emph{Confix} tries to construct sufficient DOM fixtures by encoding browser API calls as logical constraints. However, the empirical validation of Confix~\cite{amin:ase15} has shown that it only reaches about 50\% \emph{branch coverage} on the selected subjects. At the same time, search-based techniques have shown prominent results in successfully achieving higher branch coverage for imperative~\cite{wegener2001evolutionary}, object-oriented~\cite{fraser2011evosuite} and dynamic languages~\cite{irawan2016test, wibowo2015unit}, as well as for web~\cite{alshahwan2011automated} and mobile~\cite{mao2016sapienz} applications. But to the best of our knowledge, the problem of test data generation has never been tackled for JS with the help of search-based approach. In this paper we are bridging this gap by introducing a \textbf{J}avascript \textbf{E}volutionary testing framework with \textbf{D}OM as an \textbf{I}nput, called \emph{JEDI}~\cite{jedi}. We summarize our contributions as follows:
\begin{enumerate}[leftmargin=5mm]
\item The \emph{JEDI} framework is a novel JS unit testing tool using search-based techniques for generating test data. Notably, our testing framework is able to generate an arbitrary DOM input (including \emph{tags} and \emph{attributes}), which is syntactically valid and compliant with the recent HTML5 specification.
\item Our test generation algorithm, called ``genetic with restart'', attempts to escape a plateau by restarting the search with a new target. In contrast to the \emph{chaining approach}~\cite{ferguson1996chaining}, we choose the new target purely based on the preceding control flow behaviour because a full-fledged data flow analysis~\cite{jang2009points} of JS is hardly achievable.
\item Based on the case studies found in two related papers~\emph{Confix}~\cite{amin:ase15} and \emph{TAJS}~\cite{dom2011}, we conducted an empirical validation of our framework and performed a significance study of the results. The validation shows the effectiveness of the framework in covering target branches with a reasonable efficiency. Moreover, we show that out of 10 functions where \emph{JEDI} achieved complete branch coverage, \emph{Confix} only covered 32\% on average.
\end{enumerate}

The paper is structured as follows: In Section~\ref{sec.example}, we present a motivating example illustrating the challenges of generating test data for JS. The architecture of the \emph{JEDI} testing framework is explained in Section~\ref{sec.framework}. Section~\ref{sec.evaluation} presents empirical validation and the validity threats. Related and future work are discussed in Section~\ref{sec:related.work}. Section~\ref{sec:concl} concludes the paper.

%% The state of JS 2017 survey~\footnote{\url{https://stateofjs.com/}} contains an extensive list of testing frameworks including Mocha, Jasmine, Jest, Enzyme, Tape, Ava, Karma and QUnit. These frameworks support testing at various levels: unit, integration and functional. The survey also indicated a relatively low satisfaction rate of the current state of JS testing tools, scoring only 3.2 out of 5. As result, new testing frameworks such as Cypress and Storybook are constantly appearing to improve the situation. But despite this effort, test data generation continues to be poorly addressed by any of the widely used testing frameworks. The research community has actively been working towards making progress in this direction introducing such tools as Artemis~\cite{artemis2011}, JSConTest~\cite{heidegger2010contract}, Crawljax~\cite{mesbah2012crawling}, JSeft~\cite{mirshokraie2015jseft} and Jalangi~\cite{sen2013jalangi}. A recent study of client-side JS bugs~\cite{ocariza2017study} has shown that the majority (68\%) of web application faults are DOM-related and introduced in the JS code, and not in other components such as HTML or CSS. This fact indicates that yet a better testing approach is needed when it comes to unit testing of JS.
