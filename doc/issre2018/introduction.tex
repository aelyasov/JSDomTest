%% ------------------------------------------------------------------------
\section{Introduction}
\label{sec.intro}
%% ------------------------------------------------------------------------

According to the \emph{StackOverflow} Developer Survey 2018 \cite{stackoverflow2018}, JavaScript has been recognized for the sixth time in row as the most commonly used programming language. It is also the most popular language on \emph{GitHub}~\cite{guthub2017} based on the number of opened pull requests (2.3 million). Such an ever increasing JS success can be explained by its native browsers support, and the rise in popularity of the JS run-time environment \emph{Node.js}. On the other hand, due to of implicit type conversion, lack of static types, and extensive support of dynamic language constructs~\cite{richards2010analysis}, JS applications are often error-prone~\cite{frolin:TSE16}, hard to analyze~\cite{andreasen2017survey, sun2017analysis} and test~\cite{mesbah2015advances}. Thus, it is not surprising that once in a while critical bugs manage to break through~\cite{bugstories2017} into the web applications by Facebook, Twitter etc.

Systematic unit testing is basic and, at the same time, the most effective technique for improving software quality. In practice, there are numerous of JS frameworks --- Mocha, Jasmine, Jest, Enzyme, Tape, Ava, Karma, QUnit etc. --- intended to assist developers with the automation of various unit testing activities such as design, execution and monitoring. Despite the apparent abundance of the JS testing tools, the developers' satisfaction rate is still relative low~\cite{stateJS2017} (3.2 out of 5), suggesting the need for improvements. One of such areas is \emph{test data generation}. It pursues the goal of maximizing the test coverage by exercising the function under test (FUT) with different input parameters. Moreover, if a FUT interacts with the DOM of a web application, a \emph{test fixture} is expected as an additional input.

Generally, the problem of test data generation has been under an active study for the past three decades. In particular for JS, researchers have proposed several solutions based on: concolic execution (\emph{Jalangi}~\cite{sen2013jalangi}, \emph{Confix}~\cite{amin:ase15}), random generation (\emph{JSContest}~\cite{heidegger2010contract}), and the analysis of the whole web application (\emph{Artemis}~\cite{artemis2011}, Crawljax~\cite{mesbah2012crawling}). Out of those tools, only \emph{Confix} tries to construct a sufficient DOM fixture by translating native browser API calls into logical constraints. However, in the empirical evaluation~\cite{amin:ase15}, Confix only reached about 50\% in \emph{branch coverage} on the selected subjects. At the same time, search-based techniques have shown prominent results in achieving high branch coverage for imperative~\cite{wegener2001evolutionary}, object-oriented~\cite{fraser2011evosuite} and dynamic languages~\cite{irawan2016test, wibowo2015unit}, as well as for web~\cite{alshahwan2011automated} and mobile~\cite{mao2016sapienz} applications. But to the best of our knowledge, the problem of test data generation has never been tackled for JS with the help of the search-based approach. In this paper we are breaching this gap by introducing a \textbf{J}avascript \textbf{E}volution-based testing framework with \textbf{D}OM as an \textbf{I}nput, called \emph{JEDI}. We can summarize our contributions as follows:
\begin{enumerate}[leftmargin=5mm]
\item The \emph{JEDI} framework is a novel JS unit testing tool using search-based techniques for generating test data. Notably, our testing framework is able to generate an arbitrary DOM input (both tags and attributes), which is syntactically valid and compliant with the recent HTML5 specification.
\item Our test generation algorithm, called ``genetic with restart'', is trying to escape search plateau by restarting GA with a new target. Because the full-fledged JS data flow analysis~\cite{jang2009points} is hard to reach, the new target is chosen purely based on the preceding control flow behaviour in contrast with more popular techniques~\cite{ferguson1996chaining}.
\item Based on the case studies found in two related works~\emph{Confix}~\cite{amin:ase15} and \emph{TAJS}~\cite{dom2011}, we conducted an empirical validation of our framework and performed a significance study of the results. The validation has shown the effectiveness of the framework in covering target branches with a reasonable efficiency. Moreover, we showed that on the selected subjects \emph{JEDI} outperforms \emph{Confix} ....
\end{enumerate}

The paper is structured as follows: In Section~\ref{sec.example}, we present a motivating example illustrating the challenges of generating test data for JS. The architecture of the \emph{JEDI} testing framework is explained in Section~\ref{sec.framework}. Section~\ref{sec.evaluation} presents empirical validation and indicates the validity threats. Related and future work are discussed in Section~\ref{sec:related.work}. Section~\ref{sec:concl} concludes the paper.

%% The state of JS 2017 survey~\footnote{\url{https://stateofjs.com/}} contains an extensive list of testing frameworks including Mocha, Jasmine, Jest, Enzyme, Tape, Ava, Karma and QUnit. These frameworks support testing at various levels: unit, integration and functional. The survey also indicated a relatively low satisfaction rate of the current state of JS testing tools, scoring only 3.2 out of 5. As result, new testing frameworks such as Cypress and Storybook are constantly appearing to improve the situation. But despite this effort, test data generation continues to be poorly addressed by any of the widely used testing frameworks. The research community has actively been working towards making progress in this direction introducing such tools as Artemis~\cite{artemis2011}, JSConTest~\cite{heidegger2010contract}, Crawljax~\cite{mesbah2012crawling}, JSeft~\cite{mirshokraie2015jseft} and Jalangi~\cite{sen2013jalangi}. A recent study of client-side JS bugs~\cite{ocariza2017study} has shown that the majority (68\%) of web application faults are DOM-related and introduced in the JS code, and not in other components such as HTML or CSS. This fact indicates that yet a better testing approach is needed when it comes to unit testing of JS.
