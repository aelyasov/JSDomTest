%% --------------------------------------------------------------------
\section{Motivating Example}
\label{sec.example}
%% --------------------------------------------------------------------

\begin{figure}[!t]
  \begin{lstlisting}[style=htmlcssjs,language=JavaScript]
/*t dom */
function isGameFinished() {
  var obj = document.getElementById('sudoku'); |c \label{isGameFinished.getSudoku} |c
  var subDivs = obj.getElementsByTagName('DIV'); |c \label{isGameFinished.getDivs} |c
  var allOk = true;
  for (var no = 0; no < subDivs.length; no++) { |c \label{isGameFinished.inFor.begin} |c
    if (subDivs[no].className.indexOf('square') >= 0 |c \label{isGameFinished.if1.begin} |c
        && !subDivs[no].style.backgroundColor) {
      var spans = subDivs[no].getElementsByTagName('SPAN');
      if (spans[0].innerHTML != spans[1].innerHTML) { |c \label{isGameFinished.if2.begin} |c
        allOk = false; //target |c \label{isGameFinished.unfinished} |c
        break;}}}} |c \label{isGameFinished.outFor} |c
\end{lstlisting}
  \caption{JS function \texttt{isGameFinished.js} from sudoku}
  \label{code.isGameFinished}
\end{figure}

\begin{figure}[!t]
  \begin{lstlisting}[style=htmlcssjs, language=HTML5]
<!-- T1: (5,5) -->            <!-- T2: (5,6), (7,15) -->
<html>                        <html>
 <body>                        <body>
  <div id='sudoku'>             <div id='sudoku'>
                                 <div></div>
  </div>                        </div>
 </body>                       </body>
</html>                       </html>

<!-- T3: (7,8), (10,14) -->   <!-- T4: (7,8), (10,11) -->
<html>                        <html>
 <body>                        <body>
  <div id='sudoku'>             <div id='sudoku'>
   <div class='square'>          <div class='square'>
    <span></span>                 <span></span>
    <span></span>                 <span>TEST</span>
   </div>                        </div>
  </div>                        </div>
 </body>                       </body>
</html>                       </html>
  \end{lstlisting}
  \caption{Input DOM arguments for \texttt{isGameFinished.js}}
  \label{fig.isGameFinished.tests}
\end{figure}

Let us consider the JS function \texttt{isGameFinished} in Figure~\ref{code.isGameFinished} taken from the web game \emph{sudoku}~\cite{sudoku}. This function validates a sudoku solution given by a user. First, it finds a DOM element representing the game field (line~\ref{isGameFinished.getSudoku}). Then, it collects all the child \emph{divs} (line~\ref{isGameFinished.getDivs}). Each \emph{div} element corresponds to a sudoku input square (line~\ref{isGameFinished.if1.begin}), and consists of two \emph{spans}. The first \emph{span} contains a user input, whereas the second one (hidden by default) stores an expected value for that sudoku square. Inside of a for-loop in lines~\ref{isGameFinished.inFor.begin}-\ref{isGameFinished.outFor}, we iterate over the whole collection of input squares. Once, we find a square with two unequal values (line~\ref{isGameFinished.if2.begin}), the loop is terminated and the game is considered unfinished (line~\ref{isGameFinished.unfinished}) and finished otherwise.

Suppose now that we would like to unit test this function in isolation to the rest of the application. We aim to maximize the branch coverage as a common testing criteria~\cite{zhu1997software}. That is, for each individual branch of the function under test (FUT) \texttt{isGameFinished}, we need to construct a test input that covers the branch and leads to the normal termination of the FUT. A JS function can take \emph{explicit} input arguments (in our case none), but it can also accept \emph{implicit} arguments such as a DOM state. In general, in order to produce a complete test for our function we have to construct both an appropriate DOM and input arguments.

%Our program has the following branches: $(6,15)$, $(6,7)$, $(7,9)$, $(7,14)$, $(10,11)$, $(10,13)$, $(16,17)$, $(16,18)$. Four tests in

Figure~\ref{fig.isGameFinished.tests} presents four tests that together provide the full coverage of the FUT. Let us take a look at how to construct the \texttt{T4} test, which covers the branch $(10,11)$, by following the structure of the FUT. Line~\ref{isGameFinished.getSudoku} expects the input DOM to have an element with an id \textquotesingle\texttt{sudoku}\textquotesingle. In order to enter the for-loop in line~\ref{isGameFinished.inFor.begin}, that element should have at least one child \emph{div} tag. The first if-condition in line~\ref{isGameFinished.if1.begin} requires this \emph{div} to be of the class \textquotesingle\texttt{square}\textquotesingle\ and also have no background color. The second if-condition (line~\ref{isGameFinished.if2.begin}) expects that the \emph{div} consists of two \emph{span} elements whose \emph{innerHtml} values are not equal. The resulting test \texttt{T4} in Figure~\ref{fig.isGameFinished.tests} meets all the above conditions.

As we have just observed, even for such a relatively simple example, the test data generation can be far from trivial procedure because it requires the deep understanding of the program semantics. In practice, web developers often have to deal with a large number of the JS frameworks and libraries freely available on the GitHub whose code is commonly untested and poorly documented. At the same time, unit testing is the most fundamental level of testing and the easiest to implement. It saves the developers from unexpected regressions and often documents the desired behavior of a program.
