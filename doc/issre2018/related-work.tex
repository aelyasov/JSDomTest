%% --------------------------------------------------------------------
\section{Related and Future Work}
\label{sec:related.work}
%% --------------------------------------------------------------------

The last two decades have been highly productive for the research in JS testing and analysis~\cite{andreasen2017survey, sun2017analysis, mesbah2015advances}. We discuss the state-of-the-art in JS testing clustering the works by the underlying technique: feedback-directed random generation~\cite{heidegger2010contract,heidegger2012jscontest,kristensen2017type}, symbolic~\cite{tanida2014automatic,saxena2010symbolic} and concolic~\cite{sen2013jalangi,amin:ase15} execution, static~\cite{tajs2009,dom2011} and dynamic~\cite{andreasen2017survey} analysis, formal verification~\cite{gardner2008local,lerner2012modeling,gardner2012towards}, search-based testing~\cite{alshraideh2008complete}, and the whole web application testing~\cite{alshahwan2011automated,mesbah2012invariant,milani2014leveraging}.

Guided by the developer's provided type annotation, \emph{JSContest}~\cite{heidegger2010contract} generates random input for a JS function with the goal to verify the conformance of \emph{type} or \emph{access permission}~\cite{heidegger2012jscontest} contracts. It constructs test inputs out statically collected constants. In comparison, our genetic-based approach can handle interactions with the DOM, and also leverages dynamic information. $TS_{TEST}$~\cite{kristensen2017type} is the feedback-directed random testing tool for checking the conformance of TypeScript declaration files with the respective JS libraries. It supports generics but still lacks DOM generation.

%% cite heidegger2010dom

\emph{Jalangi}~\cite{sen2013jalangi} is a JS dynamic analysis framework which can be instantiated for \emph{concolic testing} or {type inconsistency} analysis~\cite{pradel2015typedevil} but it does not DOM. \emph{Confix}~\cite{amin:ase15} translates DOM-related statements into XPath expressions, and feeds them to a constrain solver in construct DOM fixtures. However, it could reinforce \Jalangi with the capability of DOM modeling. As our evaluation has shown, \Confix can not find solutions for programs with complex data dependency. SymJS~\cite{tanida2014automatic} employs symbolic execution for JS unit-test generation but again missing symbolic stubs for DOM API.

%% Another \cite{saxena2010symbolic} symbolic execution tool

Jensen et al.~\cite{tajs2009} proposed a static analysis framework \emph{TAJS} for JS type inference. Later they extend the analysis to support reasoning about HTML DOM and browser API~\cite{dom2011}. \emph{TAJS} is able to point to a dead code, type violation and references to \emph{undefined} values.

Lerner~\cite{lerner2012modeling} define formal model of event behavior in the DOM to establish testing oracles. Gardener et al.~\cite{gardner2012towards} tries to esteblish formal versification framework for JS including part of the DOM specification~\cite{gardner2008local}.

Alshraideh~\cite{alshraideh2008complete} is the only attempt to employ GA for JS test data generation. But the work deals with the functions of primitive type, without DOM, and has no not been empirically validated. Recently, SBST was applied to other dynamic languages such as Ruby~\cite{mairhofer2011search}, Lua~\cite{wibowo2015unit} and Go~\cite{irawan2016test}, but the treatment of DOM still makes our approach unique. DOM is an instance of \emph{tree-like} data structure. \emph{XMLMATE}~\cite{havrikov2014xmlmate} is an XML test generation tool build on top \emph{EvoSuite} with the aim of improving test coverage of the XML-aware Java programs. To generate a random document, it either relies on the  existing XML schema, or generates the document from scratch. In some sense, DOM specification can be thought of a complex XML schema, with extensive validation requirements. One distinction of our approach is the use of program analysis for data generation. Both tools have similar philosophy for the mutation and crossover. Jan et al.~\cite{jan2016automated} suggest to use XML fuzzing for identifying vulnerabilities in web services.

In contrast with the early presented techniques, the whole web application testing requires the application to be fully functional. This enables test generation based on crawling~\cite{mesbah2012invariant} and can be combined with the developer's written tests~\cite{milani2014leveraging}. \emph{Artemis}~\cite{artemis2011} is a feedback-directed random testing tool for JavaScript web application. It discovers new tests by generating sequences of executable events and monitoring they effect on the state of the application. Biagiola et al.~\cite{biagiola2017search} proposed to use \emph{page objects} to generate navigation path and input data with by exploiting search-based approach. \emph{JSEFT}~\cite{mirshokraie2015jseft} leverages dynamic execution to generate JS unit test including fixtures captured at run-time. The generated test can be compeented with DOM-dependent assertions produced by \emph{Atrina}~\cite{icst16}.

\emph{Flycatcher}~\cite{de2012automatic} generates tests by instrumenting a program with the help the JS \emph{Proxies} in order to collect type related information.

\emph{$JS_{DEP}$}~\cite{sung2016static} proposes a constraint-based static analysis for learning dependencies between DOM-events, which can help to prune the sequence of tests consisting of the web-application events.

%% \cite{ma2015grt} guided random testing

%% \cite{mao2016sapienz} Multi-objective automated testing for Android application

%% \cite{jquery2014}


%% ACTARUS is a static taint analysis of JS\cite{guarnieri2011saving}.


%% Salable dynamic analysis framework for JS based on shadow executions~\cite{create.citation}.

%% Information-flow security for JS~\cite{hedin2012information}.

%% Testing of AJAX application by means of crawling of the application to infer state-flow graph~\cite{mesbah2012crawling} ATUSA ~\cite{mesbah2012invariant}

%% Learning DOM invariants from multiple executions of the application~\cite{pattabiraman2010dodom}.

%% Measuring test adequacy for web application based on the DOM state coverage~\cite{mirzaaghaei2014dom}.

%% Combining human written test cases with the automatically generated once by crawling in order to extend test coverage~\cite{milani2014leveraging}.

%% DOM-aware JavaScript code completion~\cite{bajaj2014dompletion}.


%% Starting from the seminal survey of search-based test data generation~\cite{mcminn2004search}, there has been an active growth in the number of the SBST research~\cite{mcminn2011search}. Powered by the works of Wegener et at.~\cite{wegener2001evolutionary} on structural test generation, and Tonella~\cite{tonella2004evolutionary} on evolutionary class testing, it resulted in the development of EvoSuite~\cite{fraser2011evosuite} --- evolutionary framework for Java test generation.

%% % -----------------------
%% Our test generation strategy is \emph{goal-oriented}~\cite{korel1992dynamic}, i.e. it tries to find an execution leading to a goal (statement) regardless of a concrete path taken. We uses control flow graph to identify implicit dependencies between nodes.

%% The \emph{chaining approach}~\cite{ferguson1996chaining} uses data dependency to form the sequences of statements preceding the execution of a search target.
% -----------------------

\subsection{Future Work}
\label{subsec.fut.work}

One likely direction for the future extension of \emph{JEDI} is \emph{the whole test suite generation}~\cite{fraser2013whole}. Such problems usually incur multi-objective optimization~\cite{lakhotia2007multi,panichella2017lips}, e.g. trade-off between coverage and test-suite length.

Another direction of future work is re-targeting out tool towards mutation-driven generation of unit tests and oracles, similar to the line of work~\cite{fraser2012mutation}. That should also help to evaluate fault revealing capability of \emph{JEDI} as the number of killed mutants.

Similar to \cite{baars2011symbolic, galeotti2013improving}, it could be worth to combine search-based generation with concolic (symbolic) execution, e.g. investigate the integration of \Jedi with \Jalangi.

We plan to validate \Jedi on a larger set of examples. Towards this goal, we have to extend our framework with the support of such input types as user-defined classes and high-order functions. The first extension is straightforward since any class can be described as the collection of the types of class fields. To generate functions as inputs we could employ approach similar to QuickCheck~\cite{koopman2006automatic}.

%% Currently, our framework imposes certain explicit constraints on the kind of JS functions it is able to process:
%% \begin{enumerate}
%% \item ability to assign static types to input parameters
%% \item no support for the \emph{Object} type, heterogeneous arrays and high-order functions
%% \item no support for recursion
%% \item doesn't perform inter-procedural analysis
%% \item no support for JS frameworks
%% \item no reference to global variables and functions
%% \item limited support of DOM API
%% \end{enumerate}
