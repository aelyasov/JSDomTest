\documentclass[sigconf]{acmart}

\usepackage{syntax}
\usepackage{multirow}
\usepackage{booktabs} % For formal tables
\usepackage{tikz}
\usetikzlibrary{arrows,shadows,positioning,decorations.pathmorphing}
\usepackage{pgf-umlsd}
\usepackage{tikz-uml}
\usepackage{hyperref}
\usepackage{upquote}
\usepackage{listings}
\usepackage{lsthaskell}
\usepackage{xspace}
\usepackage{algorithmic}
\usepackage{longtable}
\usepackage{subcaption}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}
\usepackage[titlenotnumbered, linesnumbered, ruled]{algorithm2e} % language for algorithm description
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = blue, %Colour for external hyperlinks
  linkcolor    = red, %Colour of internal links
  citecolor    = green %Colour of citations
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkblue}{rgb}{0,0.1,0.6}
\definecolor{dkgreen}{rgb}{0,0.4,0}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}
\definecolor{dkred}{rgb}{0.5,0,0}

\definecolor{lightgray}{rgb}{0.95, 0.95, 0.95}
\definecolor{darkgray}{rgb}{0.4, 0.4, 0.4}
%\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{editorGray}{rgb}{0.95, 0.95, 0.95}
\definecolor{editorOcher}{rgb}{1, 0.5, 0} % #FF7F00 -> rgb(239, 169, 0)
\definecolor{editorGreen}{rgb}{0, 0.5, 0} % #007C00 -> rgb(0, 124, 0)
\definecolor{orange}{rgb}{1,0.45,0.13}		
\definecolor{olive}{rgb}{0.17,0.59,0.20}
\definecolor{brown}{rgb}{0.69,0.31,0.31}
\definecolor{purple}{rgb}{0.38,0.18,0.81}
\definecolor{lightblue}{rgb}{0.1,0.57,0.7}
\definecolor{lightred}{rgb}{1,0.4,0.5}
% CSS
\lstdefinelanguage{CSS}{
  keywords={color,background-image:,margin,padding,font,weight,display,position,top,left,right,bottom,list,style,border,size,white,space,min,width, transition:, transform:, transition-property, transition-duration, transition-timing-function},	
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  alsoletter={:},
  alsodigit={-}
}

% JavaScript
\lstdefinelanguage{JavaScript}{
  morekeywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break, for},
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
  morestring=[b]",
  morestring=[b]'
}

\lstdefinelanguage{HTML5}{
  language=html,
  sensitive=true,	
  alsoletter={<>=-},	
  morecomment=[s]{<!-}{-->},
  morestring=[b]'
  tag=[s],
  otherkeywords={
  % General
  >,
  % Standard tags
	<!DOCTYPE,
  </html, <html, <head, <title, </title, <style, </style, <link, </head, <meta, />,
	% body
	</body, <body,
	% Divs
	</div, <div, </div>, 
	% Paragraphs
	</p, <p, </p>,
	% scripts
	</script, <script,
  % More tags...
  <canvas, /canvas>, <svg, <rect, <animateTransform, </rect>, </svg>, <video, <source, <iframe, </iframe>, </video>, <image, </image>, <header, </header, <article, </article
  },
  ndkeywords={
  % General
  =,
  % HTML attributes
  charset=, src=, id=, width=, height=, style=, type=, rel=, href=,
  % SVG attributes
  fill=, attributeName=, begin=, dur=, from=, to=, poster=, controls=, x=, y=, repeatCount=, xlink:href=,
  % properties
  margin:, padding:, background-image:, border:, top:, left:, position:, width:, height:, margin-top:, margin-bottom:, font-size:, line-height:,
	% CSS3 properties
  transform:, -moz-transform:, -webkit-transform:,
  animation:, -webkit-animation:,
  transition:,  transition-duration:, transition-property:, transition-timing-function:,
  }
}

\lstdefinelanguage{HTML5}{
  language=html,
  tagstyle=\color{blue},
  markfirstintag=true,
  sensitive=true,
  alsoletter={<>=-},	
  morecomment=[s]{<!--}{-->},
  % tag=[s],
  %% morestring=[b]'',
  morestring=[b]',
  ndkeywords={
    % General
    =,
    % HTML attributes
    id=, class= 
  }
}


\lstdefinestyle{htmlcssjs} {%
  % General design
  backgroundcolor=\color{editorGray},
  basicstyle={\scriptsize\ttfamily},   
  frame=tb,
  % line-numbers
  xleftmargin={0.75cm},
  numbers=left,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,	
  % Code design
  identifierstyle=\color{black},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{editorGreen}\bfseries,
  stringstyle=\color{editorOcher}\ttfamily,
  commentstyle=\color{brown}\ttfamily,
  % Code
  language=JavaScript,
  alsolanguage=HTML5,
  alsodigit={.:;},	
  tabsize=2,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
  escapechar=|c
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\listfiles % used to output the versions of all files being used by the latex

\newcommand{\Server}{\emph{Server}\xspace}
\newcommand{\Client}{\emph{Client}\xspace}
\newcommand{\User}{\emph{User}\xspace}
\newcommand{\Validator}{\emph{Validator}\xspace}
\newcommand{\thenBr}{\text{then}}
\newcommand{\elseBr}{\text{else}}
\newcommand{\inFor}{\text{inFor}}
\newcommand{\inWhile}{\text{while}}
\newcommand{\un}[1]{\underline{#1}}


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\acmDOI{10.475/123_4}

% ISBN
\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[ISSTA'18]{ACM SIGSOFT International Symposium on Software Testing and Analysis}{July 2018}{Amsterdam, The Netherlands} 
\acmYear{1997}
\copyrightyear{2016}

\acmPrice{15.00}


\begin{document}
\title{Search-Based Test Data Generation for JavaScript Functions with DOM}


%% \author{
%%   \alignauthor Alexander Elyasov, Wishnu Prasetya, Jurriaan Hage\\ 
%%   \affaddr{Utrecht University, The Netherlands}\\
%%   \email{\{a.elyasov,s.w.b.prasetya,j.hage\}@uu.nl}
%% }

\author{Alexander Elyasov}
\affiliation{%
  \institution{Utrecht University}
  \city{Utrecht} 
  \country{The Netherlands} 
}
\email{a.elyasov@uu.nl}

\author{Wishnu Prasetya}
\affiliation{%
  \institution{Utrecht University}
  \city{Utrecht} 
  \country{The Netherlands} 
}
\email{s.w.b.prasetya@uu.nl}

\author{Jurriaan Hage}
\affiliation{%
  \institution{Utrecht University}
  \city{Utrecht} 
  \country{The Netherlands} 
}
\email{j.hage@uu.nl}


\begin{abstract}
This paper provides a sample of a \LaTeX\ document which conforms,
somewhat loosely, to the formatting guidelines for
ACM SIG Proceedings.\footnote{This is an abstract footnote}
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
TODO 
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}


\keywords{ACM proceedings, \LaTeX, text tagging}


\maketitle


\section{Introduction}
\label{sec.intro}
Recent empirical study of client-side JavaScript bugs~\cite{frolin:TSE16} has shown that 68\% of faults are DOM related.

Another empirical work~\cite{richards2010analysis}.

%% --------------------------------------------------------------------
\section{Motivating Example}
\label{sec.example}
%% --------------------------------------------------------------------

\begin{figure}[t]
  \begin{lstlisting}[style=htmlcssjs,language=JavaScript]
/*t dom */
function isGameFinished() {
  var obj = document.getElementById('sudoku'); |c \label{isGameFinished.getSudoku} |c
  var subDivs = obj.getElementsByTagName('DIV'); |c \label{isGameFinished.getDivs} |c
  var allOk = true;
  for (var no = 0; no < subDivs.length; no++) { |c \label{isGameFinished.inFor.begin} |c
    if (subDivs[no].className.indexOf('sudokuSquare') >= 0 |c \label{isGameFinished.if1.begin} |c 
        && !subDivs[no].style.backgroundColor) { 
      var spans = subDivs[no].getElementsByTagName('SPAN');
      if (spans[0].innerHTML != spans[1].innerHTML) { |c \label{isGameFinished.if2.begin} |c
        allOk = false; |c \label{isGameFinished.unfinished} |c
        break;
      } |c \label{isGameFinished.if2.end} |c
    } |c \label{isGameFinished.if1.end} |c
  } |c \label{isGameFinished.inFor.end} |c
  if (allOk) { |c \label{isGameFinished.if3.begin} |c 
    console.log('Congratulations! You did it'); |c \label{isGameFinished.finished} |c
  } |c \label{isGameFinished.if3.end} |c
}
\end{lstlisting}
  \caption{JS function \texttt{isGameFinished.js} from sudoku}
  \label{code.newGame}
\end{figure}

\begin{figure}[t]
  \begin{lstlisting}[style=htmlcssjs,language=JavaScript]
function isGameFinished() {
  trace.push(2);
  var obj = document.getElementById("sudoku");
  trace.push(3);
  var subDivs = obj.getElementsByTagName("DIV");
  trace.push(4);
  var allOk = true;
  loopMap[5] = function () {
    var no = 0;
    if (subDivs.length || subDivs.length == 0) {
      return Math.abs(no - subDivs.length);
    }
    return 1;
  }();
  for (var no = 0; no < subDivs.length; no++) {
    trace.push(5);
    trace.push(6);
    trace.push(7);
    if (subDivs[no].className.indexOf("sudokuSquare") >= 0 &&
        !subDivs[no].style.backgroundColor) {
      trace.push(8);
      branchDistance.push({ 
        label: 7, 
        distance: Math.min(
          abs(subDivs[no].className.indexOf("sudokuSquare"), 0) + _K_,
          absZero(subDivs[no].style.backgroundColor))
      });
      trace.push(9);
      var spans = subDivs[no].getElementsByTagName("SPAN");
      trace.push(10);
      if (spans[0].innerHTML != spans[1].innerHTML) {
      trace.push(11);
      branchDistance.push({
        label: 10,
        distance: abs(spans[0].innerHTML, spans[1].innerHTML)
      });
      trace.push(12);
      allOk = false;
      break;
      } else {
        trace.push(14);
        branchDistance.push({label: 10,distance: _K_});
      }
    } else {
      trace.push(15);
      branchDistance.push({
        label: 7,
        distance: abs(subDivs[no].className.indexOf("sudokuSquare"), 0) +
                  absNegZero(subDivs[no].style.backgroundColor)
      });
    }
  }
  trace.push(5);
  trace.push(16);
  if (allOk) {
    trace.push(17);
    branchDistance.push({label: 16, distance: absNegZero(allOk)});
    trace.push(18);
    console.log("Congratulations! You did it");
  } else {
    trace.push(19);
    branchDistance.push({label: 16 ,distance: absZero(allOk)});
  }
  trace.push(-1);
}
\end{lstlisting}
  \caption{Instrumented version of the function \texttt{isGameFinished.js} }
  \label{code.isGameFinished.instr}
\end{figure}

\begin{figure}[t]
  \begin{lstlisting}[style=htmlcssjs, language=HTML5]
<!-- T1 covers: (6,15), (16,17) -->
<html>
  <body>
    <div id='sudoku'></div>
</body>
</html>

<!-- T2 covers: (6,7), (7,14), (16,17) -->
<html>
  <body>
    <div id='sudoku'>
      <div></div>
    </div>
  </body>
</html>

<!-- T3 covers: (6,7), (7,9), (10,13), (16,17) -->
<html>
  <body>
    <div id='sudoku'>
      <div class='sudokuSquare'>
        <span></span>
        <span></span>
      </div>
    </div>
  </body>
</html>

<!-- T4 covers: (6,7), (7,9), (10,11), (16,18) -->
<html>
  <body>
    <div id='sudoku'>
      <div class='sudokuSquare'>
        <span></span>
        <span>TEST</span>
      </div>
    </div>
  </body>
</html>
  \end{lstlisting}
  \caption{Input DOM arguments for \texttt{isGameFinished.js}}
  \label{fig.isGameFinished.tests}
\end{figure}

Let us consider JS function \texttt{isGameFinished} in Figure~\ref{code.newGame} taken from the web application game \emph{sudoku}~\ref{ref.sudoku}. This function checks if a sudoku solution entered by the user is valid. First, it finds the game field element (line~\ref{isGameFinished.getSudoku}), retrieves all child divs (line~\ref{isGameFinished.getDivs}), and iterates over that collection. Each div element which corresponds to a sudoku input square (line~\ref{isGameFinished.if1.begin}) consists of two span elements. One contains a user input, and another one, which is hidden at the moment, stores the expected value for the sudoku square. Once, it finds a square where two values are not equal (line~\ref{isGameFinished.if2.begin}) to each other, the game is considered unfinished (line~\ref{isGameFinished.unfinished}) and finished otherwise (line~\ref{isGameFinished.finished}).

Suppose now that we would like to (unit) test this function in isolation to the rest of the application source code. We aim to maximize branch coverage as a common testing criteria~\cite{why.this.common}. That is for each individual branch of the function under test (FUT) \texttt{isGameFinished}, we have to construct a test input which passes the branch and normally exists the function. JS function has \emph{explicit} input arguments (none is our case), but it can also has \emph{implicit} arguments such as DOM state. As assume that DOM is the only global JS object that can be referred from the body of FUT. So in order to test our function we have to construct appropriate DOM objects as test inputs.   

%Our program has the following branches: $(6,15)$, $(6,7)$, $(7,9)$, $(7,14)$, $(10,11)$, $(10,13)$, $(16,17)$, $(16,18)$. Four tests in 

Figure~\ref{fig.isGameFinished.tests} presents four tests that together provide full coverage of the FUT. Let us look at how to construct the test that covers branch $(10,11)$. Line~\ref{isGameFinished.getSudoku} expects DOM to have an element with the id \textquotesingle\texttt{sudoku}\textquotesingle. In order to enter the for-loop on line~{isGameFinished.inFor.begin}, this element should have at least one child of the type $div$. The condition of the first $if$ (line~\ref{isGameFinished.if1.begin}) requires the div to be of the class \textquotesingle\texttt{sudokuSquare}\textquotesingle and have no background color. The last if-condition (line~\ref{isGameFinished.if2.begin}) expects that the div has two \emph{span} elements whose \emph{innerHtml} values are not equal. $T4$ in Figure~\ref{fig.isGameFinished.tests} shows a concrete example of DOM that meets all the conditions above. 

As we have just seen even for such a relatively simple example, the construction of the test input is a far from trivial procedure because it requires deep understanding the program's semantics. In practice, web developers often have to deal with the gazillion of the JS frameworks and libraries freely available on the GitHub. This code is commonly untested and poorly documented. At the same time, unit testing is the most fundamental and easiest to provide level of testing. It greatly saves developers from the unexpected regression and creates a safety belt around the application.

%% --------------------------------------------------------------------
\section{Test Generation Framework}
\label{sec.framework}
%% --------------------------------------------------------------------

\begin{figure}[t!]
  \centering 
  \begin{sequencediagram}[font=\footnotesize]

    \renewcommand\unitfactor{0.5}
    \newinst{user}{\textbf{User}}
    \newinst{server}{\textbf{Server}}
    \newinst[1]{validator}{\textbf{Validator}}
    \newinst{client}{\textbf{Client}}
    
    \begin{call}{user}{fun.js + config}{server}{\textbf{end}}
      \begin{call}{server}{Initialize(fun.js)}{server}{(cfg, branches, cinfo, ifun, sig)}
      \end{call}
      
      \begin{call}{server}{POST /init \{ifun, sig\}}{client}{status}
      \end{call}
      
      \begin{call}{server}{Select(branches)}{user}{$\text{branches}'$}       
      \end{call}
      
      \begin{sdblock}{\textbf{Genetic Loop}}{\hspace{2mm}$\text{branch} \in \text{branches}'$}
        \begin{sdblock}{\textbf{Random Loop}}{errors > 0}
          \begin{call}{server}{pop = Random(cinfo, config)}{validator}{errors}
          \end{call}
          \prelevel
        \end{sdblock}
        
        \begin{sdblock}{\textbf{Fitness Loop}}{(fitness $\neq$ 0) $\vee$ gen.limit}

          \begin{sdblock}{\textbf{Evaluation Loop}}{p $\in$ pop}
            \begin{call}{server}{POST /genetic \{p\}}{client}{response = ifun(p: sig)}
            \end{call}
            
            \begin{callself}{server}{Evaluate(branch, cfg, response)}{fitness}
            \end{callself}
            \prelevel
          \end{sdblock}
          
          \begin{sdblock}{\textbf{Crossover Loop}}{errors > 0}
            \begin{call}{server}{cross = Crossover(cinfo, pop)}{validator}{errors}
            \end{call}
            \prelevel
          \end{sdblock}

          \begin{sdblock}{\textbf{Mutation Loop}}{errors > 0}
            \begin{call}{server}{mut = Mutation(cinfo, pop)}{validator}{errors}
            \end{call}
            \prelevel
          \end{sdblock}
         
          \begin{callself}{server}{pop = cross $\cup$ mut}{pop}
          \end{callself}
          \prelevel
        \end{sdblock}
        \mess{server}{best fitness}{user}
        
      \end{sdblock}
    \end{call}
  \end{sequencediagram}
  \caption{Architecture of the test framework}
  \label{fig.framework.architect} 
\end{figure}

Given JS function $f$ and a set of branches $\mathbb{B}_f$, the ultimate goal of the testing framework is to find input arguments for $f$ that cover all branches from $B_f$. We implemented such a framework as a client-server application which uses under the hood genetic test generation engine. The general workflow of the framework is depicted as a sequence diagram in Figure~\ref{fig.framework.architect}. The diagram consists of the four interacting components \User, \Server, \Validator, and \Client. \Server is the key component of the whole framework. It is responsible for the \emph{Initialization Phase} and test data generation in the \emph{Genetic Phase}. Both phases will be covered in details in Section~\ref{sub.sec.init.phase} and \ref{sub.sec.genetic.phase} respectively. Each newly constructed HTML document has to be processed by the \Validator\footnote{\url{https://validator.w3.org/nu/}} which checks its syntactical correctness and reports back the set of identified errors. \Server rejects the document if any errors were revealed and repeats the current step until the generated document has no errors anymore. \Client is a \emph{Node.js}\footnote{\url{https://nodejs.org/en/}} application that is mainly responsible for the execution of the JS code. We use the \emph{jsdom}\footnote{\url{https://github.com/tmpvar/jsdom}} library to model the virtual DOM and simulate native browser API calls.   

Let us give a closer look at the sequence of interactions in Figure~\ref{fig.framework.architect}. As an input to our testing framework, \User has to provide the JS file \emph{fun.js} that contains the function under test (FUT) \emph{fun} annotated with the type signature. Additionally, \User specifies a configuration file \emph{config} that defines various parameters for random data generation, genetic phase, logging etc. Experimentally, we have found an optimal set of input configurations that was used across all the experimental subjects in Section~\ref{sec.evaluation}. The received data is processed by \Server during the \emph{Initialization Phase}. At the end of it we get the following information back: the control flow graph (\emph{cfg}) of \emph{fun}, the list of its branches (\emph{branches}), the \emph{fun}'s  constant (\emph{cinfo}) info, the instrumented version \emph{ifun} of \emph{fun}, and the \emph{fun}'s signature (\emph{sig}). \Server sends a \texttt{POST} request to the \Client to store there \emph{ifun} and \emph{sig}. Depending on the chosen execution mode, the \Server either asks the \User to select the target branch or covers all branches one by one in a fixed order. For each branch our framework enters the \emph{Genetic Loop (Phase)}. Inside of this phase, the framework starts with a randomly generated population (\emph{Random Loop}), and continues to evolve the population (\emph{Fitness Loop}) until either a perfect entity is found or a certain termination criteria is achieved, e.g. the limit of generation attempts is reached. Each candidate in the population has to be evaluated in \emph{Evaluation Loop} by \Client. It matches the candidate $p$ according the known type signature \emph{sig} and invokes the instrumented JS function \emph{ifun(p)}. The execution trace along with some collected information are sent back to the \Server, where the final fitness value is computed. The new population is constructed by combining the results of the \emph{Crossover} and \emph{Mutation Loops}. If an HTML document is produced during one the genetic phases, it has to be approved by the \Validator first. At the end of the \emph{Fitness Loop} the candidate with the ``best'' fitness value is reported back to the \User. Once all branches are exercised, the algorithm reaches the end. In the follow up two sections we elaborate on the details of each individual component of our test generation framework.

\subsection{Initialization Phase}
\label{sub.sec.init.phase}

\begin{algorithm}[t!]
  \caption{Initialization Phase}
  \label{alg.init}
  \algsetup{linenosize=\tiny}
  \scriptsize
  \DontPrintSemicolon
  \SetAlgoVlined
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  \SetKwInOut{Require}{Require}
  \SetKwProg{Fn}{Function}{}{}
  \Input{JS file $fun.js$ with FUT and type annotation }
  \Output{Tuple $(cfg, branches, cinfo, ifun, sig)$}
  \Fn{$Initialize(fun.js)$}{
 
    $(ast, sig) \longleftarrow ParseFuncAndSig(fun.js)$\label{alg.init.parse.fun.sig}\;
    $cinfo \longleftarrow GetConstantInfo(ast)$\label{alg.init.collect.info}\;
    $nast \longleftarrow NormalizeAST(ast)$\label{alg.init.transform.ast}\;
    $ifun \longleftarrow Instrument(nast)$\label{alg.init.instr}\;
    $cfg \longleftarrow BuildCFG(nast)$\label{alg.init.build.cfg}\;
    $branches \longleftarrow GetBranches(cfg)$\label{alg.init.get.branches}\;
    \Return{$(cfg, branches, cinfo, ifun, sig)$}
    }
\end{algorithm}

During the \emph{Initialization Phase} we analyze FUN and collect data necessary for the consecutive genetic testing phase. The main steps of the initialization are illustrated in Algorithm~\ref{alg.init}. Given a FUT \emph{fun.js} as an input, we parse the function and its type signature in line~\ref{alg.init.parse.fun.sig}. In order to maximize the chances of generating the fittest candidate in the genetic phase, we perform a static analysis of the FUT with the purpose to collect constant info in line~\ref{alg.init.collect.info}. Such constants include string and numeric literals as well as the arguments to the following DOM API methods:
\begin{itemize}
\item \texttt{getElementsByTagName}
\item \texttt{getElementById}
\item \texttt{getElementsByClassName}
\item \texttt{getElementsByName}
\end{itemize}
which respectively signify the reference to the \emph{tags}, \emph{ids}, \emph{classes} and \emph{names} used in the FUT. Next step is normalizing the FUT before applying any instrumentation (line~\ref{alg.init.transform.ast}), e.g. we need to transform \emph{if-then} branches into \emph{if-then-else}. We need to instrument the FUT (line~\ref{alg.init.instr}) in order be able to collect the run-time data such as the execution trace, the approach level, the branch and loop distances, and the constants. Upon the $ifun$ execution this information is gathered and fed back to the fitness evaluation procedure. The last two steps are to construct the control-flow graph (line~\ref{alg.init.build.cfg}) and identify all branches of the FUT (line~\ref{alg.init.get.branches}).

\subsubsection{Supported Types}
\label{sub.sec.sup.types}

\begin{figure}[t]
\setlength{\grammarparsep}{3pt}
\small
\begin{grammar}

<JS Type Annotation> ::= /*t <Signature> */

<Signature> ::= <DOM> : <Type Signature> | <Type Signature>

<DOM> ::= \texttt{dom}

<Type Signature> ::= <Type> | <Type> : <Type Signature>

<Type> ::= <Void Type> | <Primitive Type> | <Array Type>

<Primitive Type> ::= \texttt{bool} | \texttt{int} | \texttt{float} | \texttt{string}

<Array Type> ::= [ <Primitive Type> ] | [ <Array Type> ]
\end{grammar}
\caption{Grammar of supported JS type annotations}
\label{fig.js.type.annot}
\end{figure}

The grammar of JS type annotations supported by our test generation framework is shown in Figure~\ref{fig.js.type.annot}. Each type annotation is a signature surrounded with a specialized JS type comment (\texttt{/*t...*/}). We distinguish two between kinds of signatures those who refer to the global DOM and ``ordinary'' JS type signatures. Functions with a DOM signature expect a \texttt{dom} argument being passed as the first implicit parameter to the function call. Ordinary JS signature is a non-zero sequence of JS types. The type can be \emph{Void}, \emph{Primitive} (\texttt{bool}, \texttt{int}, \texttt{float}, \texttt{string}) or \emph{Array} (recursive homogeneous array type).  


\subsection{Genetic Phase}
\label{sub.sec.genetic.phase}

\begin{algorithm}[!t]
  \caption{Genetic Phase}
  \label{alg.gen}
  \algsetup{linenosize=\tiny}
  \scriptsize
  \DontPrintSemicolon
  \SetAlgoVlined
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  \SetKwInOut{Require}{Require}
  \SetKwProg{Fn}{Function}{}{}
  \Input{
    $config$ is a GA configuration file\\
    $b_n$ is a target branch of FUT\\
    $(cfg, branches, cinfo, ifun, sig)$ output of Algorithm~\ref{alg.init}
  }
  \Output{
     $(f^*, p^*)$ the best population candidate and its fitness score
  }
  \Fn{$Genetic(b_n, cfg, cinfo, config, ifun, sig)$}{
    $(size_P, size_A, size_G, rate_C, rate_M,size_{H}) \longleftarrow Read(config)$\label{alg.gen.read.config}\;
    $target \longleftarrow b_n$\label{alg.gen.init.target}\; 
    $i \longleftarrow 0 $\label{alg.gen.iter.count}\;
    \Repeat{$\neg historyConverged \vee (i > size_G)$}{\label{alg.gen.converged.loop.begin}
      $archive \longleftarrow \emptyset$\label{alg.gen.init.archive}\; 
      $history \longleftarrow \emptyset$\label{alg.gen.init.history}\; 
      $pop \longleftarrow Random(cinfo, size_P)$\label{alg.gen.random.gen}\;
      \Repeat{$isPerfect(f^*) \vee historyConverged \vee (i > size_G)$}{\label{alg.gen.loop.begin}
        $scoredPop \longleftarrow \emptyset$\;
        $history \longleftarrow history \cup archive$\;
        \ForAll{$p \in pop$}{\label{alg.gen.eval.begin}
          $args \longleftarrow CoerceArguments(p, sig)$\label{alg.gen.make.args}\;
          $(tr, d_B, d_L, dyncinfo) \longleftarrow ifun(args)$\label{alg.gen.call.ifun}\;
          $f \longleftarrow Score(target, cfg, tr, d_B, d_L)$\label{alg.gen.eval}\;
          $cinfo \longleftarrow cinfo \cup dyncinfo$\label{alg.gen.eval.end}\;
          $scoredPop \longleftarrow (f, p) \cup scoredPop$\;
        }
        $combo \longleftarrow scoredPop \cup archive$\label{alg.gen.get.combo}\;
        $cross \longleftarrow Crossover(combo, rate_C)$\label{alg.gen.cross}\;
        $mut \longleftarrow Mutation(combo, cinfo, rate_M)$\label{alg.gen.mut}\;
        $pop \longleftarrow cross \cup mut$\label{alg.gen.new.pop}\;
        $archive \longleftarrow SortArchive(combo, size_A)$\label{alg.gen.new.archive}\;
        $(f^*, p^*) \longleftarrow head(archive)$\label{alg.gen.archive.head}\;
        $i \longleftarrow i + 1$\;
        $historyConverged \longleftarrow hasConverged(history, size_H)$\label{alg.gen.has.converged}\;
      }\label{alg.gen.loop.end}
      $target \longleftarrow NewTarget(branches, b_n)$\label{alg.gen.new.target}\;
    }\label{alg.gen.converged.loop.end}
    \Return{$(f^*, p^*)$}\label{alg.gen.return} 
  }
\end{algorithm} 

The heart of our test data generation framework is in the \emph{Genetic Phase}. The main workflow of the underlying genetic algorithm (GA) is, though, being fairly standard~\cite{poli2008field} but has been extended with the concept of \emph{archive convergence} (Algorithm~\ref{alg.gen}). We get as an input a configuration file \emph{config}, a target branch $b_n$ of the FUT (which we would like to cover), and the tuple of parameters computed by Algorithm~\ref{alg.init}. The output consists of the ``best'' fitness score $f^*$ achieved on the population candidate $p^*$.

First, we read the \emph{config} file (line~\ref{alg.gen.read.config}) and retrieve the following GA configuration parameters: 
%% \begin{itemize}
%% \item $size_P$ is the size of the genetic population
%% \item $size_A$ is the size of the genetic archive
%% \item $size_G$ is the total number of the genetic iterations
%% \item $rate_C$ is a crossover rate
%% \item $rate_M$ is a mutation rate
%% \item $size_H$ is a history window size
%% \end{itemize}
a population size  ($size_P$), an archive size ($size_A$), the number of generations ($size_G$), crossover ($rate_C$) and mutation ($rate_M$) rates respectively, and a history window size ($size_H$). We set the initial target to $b_n$ (line~\ref{alg.gen.init.target}) and the iteration counter $i$ to 0 (line~\ref{alg.gen.iter.count}). Until the history of archives has not converged or the limit of the generations has not been reached, we are initializing the genetic search of the target branch (lines~\ref{alg.gen.converged.loop.begin}-\ref{alg.gen.converged.loop.end}). An \emph{archive} stores the most fitted population candidates observed so far. It is empty in the beginning of the evolution (line~\ref{alg.gen.arch.init}) as well as the history of archives \emph{history} (line~\ref{alg.gen.init.history}). The first population of $size_P$ elements is randomly generated out of the constants taken from \emph{cinfo} (line~\ref{alg.gen.random.gen}). Then, in loop lines~\ref{alg.gen.loop.begin}-\ref{alg.gen.loop.end}, this population is evolved until either the perfect candidate is found or the history of archives is converged or the generation limit $size_G$ is reached. But the first step in this loop is scoring the current population~\ref{alg.gen.eval.begin}-\ref{alg.gen.eval.end}. Each candidate of the population represents a concrete argument list of the FUT so it has to be coerced with respect to the type signature $sig$ (line~\ref{alg.gen.make.args}). After calling the instrumented function \emph{ifun} on $args$ (line~\ref{alg.gen.call.ifun}), we get 4-tuple consisting of an execution trace ($tr$), the sets of branch ($d_B$) and loop distances ($d_L$), and dynamic constant info (\emph{dyncinfo}) collected at the run-time. The next step is actually scoring the fitness value for the given population candidate (line~\ref{alg.gen.eval}). Collected constants \emph{dyncinfo} are merged with existing constant pool (line~\ref{alg.gen.eval.end}). Eventually, the scored population is combined with the archive (line~\ref{alg.gen.get.combo}) and it is used for the crossover (line~\ref{alg.gen.cross}) and mutation steps (line~\ref{alg.gen.mut}). The rates specify the proportion in with two operation contribute the formation of the new population (line~\ref{alg.gen.new.pop}). The scored population together with the current archive are sorted by the fitness value, and the best $size_A$ elements form a new archive (line~\ref{alg.gen.new.archive}). The element at the top of the archive is the fittest candidate (line~\ref{alg.gen.archive.head}). The fitness value of that element defines if a perfect candidate is found (line~\ref{alg.gen.loop.end}). Eventually, the tuple $(f^*, p^*)$ is returned by the algorithm (line~\ref{alg.gen.return}).

In some cases, when we do get enough guidance from the fitness function, the genetic algorithm converges to a local minimum~\cite{ga.flag.problem.or.survey}. For example, if one branch is dominated by another, the coverage of the former branch depends on the coverage of the latter. Unless this relation is captured by the branch condition on the former branch, the respective fitness function does not reflect on the branch dependency. In this situation, we find ourselves being trapped on a flat space, with a small unreliable chance to escape. In order to overcome this problem, we propose a novel --- to the best of our knowledge --- solution based on the idea of \emph{archive convergence}. If during a certain history window, the fitness values of the respective archives converge to a fixed point, we restart the genetic search and redefine the search target. At the end of the evolution loop (line~\ref{alg.gen.has.converged}), we compute the convergence condition of the fitness values in the first $size_H$ archives taken from the history. If the fitness has converged (line~\ref{alg.gen.loop.end}), the genetic algorithm is restarted with a new target. It consists of the original branch $b_n$ prefixed with a branch $b \in branches$ which our branch depends on (line~\ref{alg.gen.new.target}). Every time genetic search converges, we produce a new partial path by eventually covering all possible executions leading to $b_n$. In practice, we limit this process by the target of length two.

In the rest of this section, we elaborate on the technical details of the genetic algorithm such as random generation in Section~\ref{sub.sub.sec.random.html}, mutation and crossover in Section~\ref{sub.sub.sec.genetic.oper}, and fitness function in Section~\ref{sub.sub.sec.fitness.fun}. Our primary focus in those sections will be on the generation and transformation of the HTML documents. Table~\ref{} descries how similar operations are implemented for primitive and array JS types. 

\begin{table}
  \caption{Genetic Operation for JS types}
  \label{tbl.gen.oper.js.types}
    \footnotesize
  \begin{tabular}{p{1cm}|p{5mm}|p{6cm}}
    \toprule
    \textbf{Operation} & \textbf{Type} & \textbf{Description} \\
    \hline
    Random & Bool & choose at random \{\texttt{true}, \texttt{false}\} \\
    Random & Int  & with 80\% probability choose an integer from [-10, 10], or with 20\% from integer constants\\
    Random & Float & with 80\% probability choose an float from [-10.0, 10.0], or with 20\% from float constants\\
    Random & String & with 80\% probability make a random string up to length five composed characters \texttt{[a-zA-Z0-9]}, or with 20\% from string constants\\
    Random & Array & make a random array of a respective type upto length five\\
    \hline
    Crossover & Bool   & pick at random one out of two given boolean \\
    Crossover & Int    & pick at random one out of two given integers\\
    Crossover & Float  & pick at random one out of two given floats\\
    Crossover & String & choose independently crossover point for each string, swap ends, and pick result at random\\
    Crossover & Array & similar crossover operator as for strings\\
    \hline
    Mutation & Bool & Flip the boolean constant\\
    Mutation & Int  & Generate a new integer value, on increase (decrease) by 1 or 10 the given one\\
    Mutation & Float  & Generate a new float value, on increase (decrease) by 0.1, 1 or 10 the given one\\
    Mutation & String & Generate an new string values, remove a random character in a string, or replace a successor (predecessor) a random character\\
    Mutation & Array & Mutate a random element in array according to its type\\
    \bottomrule
  \end{tabular}
\end{table}

\subsubsection{Random HTML Generation}
\label{sub.sub.sec.random.html}

We want to generate HTML as it is specified by WHATWG\footnote{\url{https://html.spec.whatwg.org}}. HTML is an XML-family markup language that uses special tags and attributes to describe document structures on the Web. Recent HTML5 standard defines more than hundred of tags and attributes which both have to comply with extremely complex logic to constitute a syntactically valid HTML. Browsers are usually tolerant to syntactic errors in HTML. They will silently fix them and display the page anyway.

In order to support the variability of HTML content, we have developed an eDSL that prescribes the generation of syntactically valid HTML. This was a challenge on its own because, as we have mentioned early, the complexity of HTML and lack of formal specification. Our language is inspired by QuickCheck~\cite{claessen2011quickcheck} and essentially employs the library\footnote{\url{https://hackage.haskell.org/package/QuickCheck}} to define an \texttt{Arbitrary} instance for the \texttt{Html} data type. With some technical details left out for the sake of simplicity, Figure~\ref{fig.html.arb.def} highlights that definition. Data type \texttt{HtmlState} (lines~\ref{ref.HtmlState.begin}--\ref{ref.HtmlState.end}) describes the internal state of \texttt{Html} during generation. The state is composed of the following components:
\begin{itemize}
\item \texttt{depth} and \texttt{degree} specify maximum depth and node degree of HTML respectively
\item \texttt{ctx} is the current value of the HTML content model stack 
\item \texttt{tagFreq} provides statistical information about the frequency of tags in HTML
\item \texttt{tags}, \texttt{ids} and \texttt{classes} are predefined sets of HTML elements which are given preference in the generation process.  
\end{itemize}
Combined with the random generation monad \texttt{Gen}, this state is wrapped into a state monad transformer~\cite{jones1995functional} (line~\ref{ref.GenState}) which returns the randomly generated \texttt{Html} (line~\ref{ref.GenHtmlState}). Each HTML tag should be defined as a value of type \texttt{GenHtmlState}. Lines~\ref{ref.generateHTML.begin}--\ref{ref.generateHTML.end} show an example of content generation for the \texttt{<html>} tag. According to its specification\footnote{\url{https://html.spec.whatwg.org/multipage/semantics.html\#the-html-element}}, the tag is composed of the \texttt{<head>} tag followed by the \texttt{<body>} tag. First, we store the state of HTML generation and retrieve the current the depth (lines~\ref{ref.generateHTML.getState} and \ref{ref.generateHTML.getDepth} respectively). Then, if depth is equal to zero, we just return some string constant (line~\ref{ref.generateHTML.returnString}). Otherwise, we update the state with the depth decreased by one, generate new content for \texttt{head} and \texttt{body}, and return their combination (lines~\ref{ref.generateHTML.updateState}, \ref{ref.generateHTML.newHead}, \ref{ref.generateHTML.newBody} and \ref{ref.generateHTML.end} respectively).

\begin{figure}[t]
  \begin{haskell}
instance Arbitrary Html where
  arbitrary = evalStateT generateHTML defaultState

generateHTML :: GenHtmlState |c \label{ref.generateHTML.begin} |c
generateHTML = do
  state <- get |c \label{ref.generateHTML.getState} |c   
  let d = getDepth state |c \label{ref.generateHTML.getDepth} |c
  if d == 0
  then lift \dollar return \dollar toHtml "HTML" |c \label{ref.generateHTML.returnString} |c
  else do put state{depth = d - 1} |c \label{ref.generateHTML.updateState} |c
           head <- generateHEAD |c \label{ref.generateHTML.newHead} |c
           body <- generateBODY |c \label{ref.generateHTML.newBody} |c
           lift\dollar return \dollar docTypeHtml \dollar head >> body |c \label{ref.generateHTML.end} |c

data Tag = HTML | HEAD | BODY | ...
type Context = CFlow | CMetadata | ...
data HtmlState = |c \label{ref.HtmlState.begin} |c
  HtmlState { depth      :: Int 
             , degree    :: Int    
             , ctx       :: Stack Context 
             , tagFreq   :: [(Int, Tag)] 
             , tags      :: [Tag]
             , ids       :: [String]
             , classes   :: [String] } |c \label{ref.HtmlState.end} |c
type GenState s = StateT s Gen |c \label{ref.GenState} |c
type GenHtmlState = GenState HtmlState Html |c \label{ref.GenHtmlState} |c
  \end{haskell}
  \caption{\texttt{Arbitrary} instance for \texttt{Html} data type}
  \label{fig.html.arb.def}
\end{figure}

\subsubsection{Genetic HTML Operations}
\label{sub.sub.sec.genetic.oper}

In essence, HTML document is a labeled tree with \emph{tags} instead of nodes and \emph{attributes} as labels. Therefore crossover and mutations are defined similar to those concepts for the expression trees in genetic programming.  

\textbf{HTML Crossover} takes two HTML trees, randomly picks a node in each tree, and returns the first tree with a sub-tree swapped from the second tree.

\textbf{HTML Mutations} are of three categories: \emph{NewTree}, \emph{DropTree}, and \emph{ShuffleAttributes}. \emph{NewTree} simply generate a new tree based on the given state of constant pool. \emph{DropTree} mutation selects a node in a tree and drops the sub-tree starting from that node. \emph{ShuffleAttributes} for a given tree and an attribute type, re-assigns the attributes of the specified type on that tree. Currently we instantiated the \emph{ShuffleAttributes} mutation for only for two types of attributes \emph{class} and \emph{id}, which gave us it total four variations for mutation. Each time a mutation is performed the type is chosen uniformly. In the future we consider experiment with assigning some priorities to curtain mutations.  

\subsubsection{Fitness Function}
\label{sub.sub.sec.fitness.fun}

Success of any search-based algorithm heavily relies on the choice of the fitness function (FF) that guides the evolution process. Our search target is a specific branch of the program under test that we want to cover by generating a valid input data. The input is \emph{valid} only if the program normally terminates on it, i.e. without premature exception. Thus, our search target is an ordered pair of CFG nodes $(n_b, n_x)$ where $n_b$ is the label of the target branch, and $n_x$ is the normal exit node of the program. FF for a CFG node is traditionally defined as a combination of the \emph{approach level} and the normalized \emph{branch distance}\cite{arcuri2010does}. 
\[
\mathcal{F}(n) = \text{Approach Level} + \alpha({\text{Branch Distance}})
\]

Therefore, the resulted FF ($\mathcal{F}^*$) is an ordered pair of the FFs of the respective nodes.   

\[
\mathcal{F}^*(n_b, n_x) = (\mathcal{F}(n_b), \mathcal{F}(n_x))
\]

%% --------------------------------------------------------------------
\section{Empirical Evaluation}
\label{sec.evaluation}
%% --------------------------------------------------------------------

In order to evaluate practical feasibility of the test framework adoption, we conducted an empirical validation on a set of case studies described in Section~\ref{sub.sec.case.studies}. All the experiments were performed in a batch mode on a cluster machine with 32 HT Cores and 256 GB RAM running under Scientific Linux 7.3. We have created three different instances of our JS testing framework each is based a slight variation of the underlying genetic search algorithm. The first version is \emph{Random} ($R$), i.e. instead of applying crossover and mutation we regenerate new population from scratch. It worth to notice, that random version also benefits from both preliminary static analysis phase and dynamic constant propagation during fitness evaluation step. The second version is \emph{Genetic} ($G$) and it literally follows all of the steps prescribed by the genetic framework in Figure~\ref{fig.framework.architect}. The last version ($G10$) is based on the genetic algorithm~\ref{alg.gen} where search is restarted after the archive is converged within a given history window, which is equal to 10 in our case. Initially, we experimented with two different window sizes 5 and 10. On one hand, a smaller window size forces the GA to converge fast and early discover a potential flat space. On the other hand, it sometimes causes a premature convergence by not letting the right genetic combination to be triggered. We experimentally concluded that the window size 10 works best for our examples and present the rest of the analysis based on that result. Table~\ref{tbl.gen.config} summarizes the configuration parameters for all three proposed test generation strategies. The choice of initial values is similar to other genetic testing frameworks, e.g. \emph{EvoSuite}~\cite{evosuite}. 

\begin{table}
  \caption{Genetic Algorithm Configurations}
  \label{tbl.gen.config}
    \scriptsize
  \begin{tabular}{l|r|r|r}
    \toprule
    \textbf{Parameter Name} & \textbf{R} & \textbf{G} & \textbf{G10} \\
    \hline
    Population size                   & 50  & 50  & 50  \\
    Archive size                      & 1   & 25  & 25  \\
    Maximum number of generations     & 200 & 200 & 200 \\
    Crossover rate                    & 0   & 0.5 & 0.5 \\
    Mutation rate                     & 0   & 0.5 & 0.5 \\
    History window size               & 200 & -   & 10  \\
    \bottomrule
  \end{tabular}
\end{table}


\subsection{Case Studies}
\label{sub.sec.case.studies}

Being one of the most popular programming languages of the modern time, there are ample open source JS projects on the Web. Being written with the help of countless number of specialized JS libraries, JS applications greatly vary in size, complexity and coding style. Moreover, some popular JS web-frameworks, such as jQuery and React\footnote{\url{http://todomvc.com/}}, offer an alternative approach to the native DOM manipulation. In order to choose suitable case-studies, we need to scrutinize the source code of the JS applications which is time consuming and labor intensive process. Therefore, we decided to primarily focus on the evaluation of the JS subjects well-established in the related research literature such as \emph{Confix}~\cite{amin:ase15} and \emph{TAJS}\footnote{\url{http://www.brics.dk/TAJS/dom-benchmarks/}}~\cite{dom2011}. Both of these works address the problem of testing of JS application with the reference to the browser DOM. Since our testing framework is capable of dealing with the browserless imperative JS code as well, we introduced two additional case-studies \emph{mathjs}\footnote{\url{https://github.com/josdejong/mathjs/}} and \emph{cs-in-js}\footnote{\url{https://github.com/nzakas/computer-science-in-javascript}}. For each case-study application, we identified several JS functions that are suitable for our testing framework. In the end, our evaluation set included both primitive and DOM related JS functions.

Table~\ref{tbl.case.studies} presents some common quantitative characteristics for the selected case-studies. For each function of a case-study we reported the following metrics\footnote{\url{http://jsmeter.info/} is the measurement tool}: lines of code (\textbf{\#LOC}), number of branches (\textbf{\#BR}), depth (\textbf{\#D}), cyclomatic complexity (\textbf{CC}), halstead volume (\textbf{HV}) and maintainability index (\textbf{MI}). The four rightmost columns \textbf{DOM}, \textbf{id}, \textbf{tag} and \textbf{class} indicate if the function manipulates with the \emph{dom}, \emph{id}, \emph{tag} or \emph{class} respectively.      

\begin{table*}[t]
  \caption{Summary of the Case-Studies}
  \label{tbl.case.studies}
  %\resizebox{\textwidth}{!}{
    \scriptsize
  \begin{tabular}{l|c|l|l|r|r|r|r|r|r|c|c|c|c}
    \toprule
    \textbf{case-study} & \textbf{?} & \textbf{function} & \textbf{type signature} & \textbf{\#LOC} & \textbf{\#BR} & \textbf{\#D} & \textbf{CC} & \textbf{HV} & \textbf{MI} & \textbf{DOM} & \textbf{id} & \textbf{tag} & \textbf{class} \\
    \hline
    sudoku     & + & helpMe & (dom,int,int)    & 14 & 2 & 3 & 3 & 344 & 107.58 & + & + & + & - \\
    sudoku     & + & isGameFinished & (dom)    & 10 & 3 & 3 & 4 & 370 & 112.55 & + & + & + & + \\
    sudoku     & + & newGame & (dom)           & 9  & 1 & 2 & 2 & 326 & 115.15 & + & + & + & + \\
    sudoku     & + & revealAll & (dom)         & 8  & 0 & 2 & 1 & 312 & 117.44 & + & + & + & - \\
    sudoku     & - & showCell & (dom)         & 8  & 0 & 0 & 1 & 232 & 118.46 & + & + & + & - \\
    sudoku     & + & shuffleBoard & (dom)      & 23 & 2 & 3 & 3 & 555 & 97.9   & + & - & + & - \\
    sudoku     & - & switchLevel & (dom,bool) & 10 & 1 & 2 & 2 & 257 & 114.26 & + & - & + & - \\
    \hline
    phormer    & + & toggleInfo & (dom,string)                                                      & 16 & 3 & 1 & 4 & 570  & 103.46 & + & + & - & - \\
    phormer    & - & update & (dom,int,[string],bool,[string],[string],bool,[string],[string],int) & 35 & 5 & 3 & 6 & 1190 & 87.804 & + & + & - & - \\
    phormer    & - & updateIndic & (dom,bool)                                                      & 16 & 3 & 1 & 4 & 361  & 105    & + & + & - & - \\
    \hline
    hotel RS   & - & RequiredField & (dom,[string]) & 11 & 2 & 2 & 5 & 247  & 112.16 & + & + & - & - \\
    hotel RS   & + & isValidCard & ([int])           & 17 & 2 & 2 & 5 & 351  & 103.91 & - & - & - & - \\
    hotel RS   & - & isValidMasterCard & ([int])     & 5  & 4 & 1 & 7 & 130  & 126.67 & - & - & - & - \\
    hotel RS   & + & isValidVISA & ([int])           & 6  & 3 & 1 & 6 & 104  & 124.71 & - & - & - & - \\
    hotel RS   & - & validateNumber & (dom,string)  & 7  & 1 & 1 & 4 & 98.1 & 122.87 & + & + & - & - \\
    \hline
    apophis    & - & doRain & (dom,string,int,int,int,int,int,int)                                  & 10 & 3 & 2 & 4 & 242 & 114.1  & + & + & - & -\\
    apophis    & - & drawShields & (dom,[int])                                                      & 6  & 1 & 2 & 2 & 212 & 123.19 & + & + & - & - \\
    apophis    & - & fireMeteor & (int,[int],int,[int],[int],[int],int,int,[int],[int],int,int,int) & 15 & 3 & 2 & 4 & 539 & 104.70 & - & - & - & - \\
    apophis    & - & getReady & (dom,int,int,int,int,int,int)                                       & 16 & 2 & 2 & 3 & 410 & 104.82 & + & + & - & - \\
    apophis    & + & initShields & (dom,[int],int,int)                                               & 6  & 0 & 1 & 1 & 310 & 122.12 & + & + & - & -\\
    \hline
    bingbong   & + & brickJiggler & (dom,int,int,int,[int],[int],[int],[int]) & 7  & 1  & 1 & 2  & 305  & 119.45 & + & + & - & - \\
    bingbong   & + & doPaddlePower & (dom,int,int)                            & 15 & 2  & 1 & 3  & 353  & 106.38 & + & + & - & - \\
    bingbong   & + & initBricks & (dom,[int],int,int)                         & 70 & 12 & 4 & 13 & 2380 & 72.594 & + & + & - & - \\
    bingbong   & - & drawLevel & (dom,int,int,int,int)                       & 22 & 2  & 3 & 3  & 703  & 97.816 & + & + & - & - \\
    bingbong   & - & goPing & (dom,int,int,int)                              & 12 & 2  & 2 & 3  & 268  & 110.93 & + & + & - & - \\
    \hline
    burncanvas & + & do\_draw & (int,int,int,int,int,int,int)                 & 40 & 12 & 2 & 14 & 583 & 86.214 & - & - & - & - \\
    \hline
    cs-in-js   & - & luhn-algorithm & (string,bool)                          & 20 & 3 & 2 & 6 & 308 & 101.49 & -  & -  & - & - \\
    cs-in-js   & - & quicksort-partition & ([int],int,int)                   & 21 & 1 & 1 & 3 & 309 & 101.38 & -  & -  & - & - \\ 
    \hline
    mathjs     & + & prob\_gamma & (float)                                    & 57 & 8  & 2 & 16 & 1370 & 77.121 & - & - & - & - \\
    \bottomrule
  \end{tabular}
%}
\end{table*}

\subsection{Research Questions}
\label{sub.sec.research.questions}

\begin{description}
\item[\textbf{RQ1:}] What is the performance of our test generation framework? Is there any difference in performance on examples with DOM and without?  Which algorithm works best random, genetic or genetic with restart?
\item[\textbf{RQ2:}] What is the cost of one iteration of each algorithm?
\item[\textbf{RQ3:}] How does the branch coverage progress over time given a fixed budget per branch? 
\end{description}

\subsection{Results}
\label{sub.sec.eval.results}

\setlength\tabcolsep{0.8pt}
\begin{table}[!t]
  \caption{Performance statistics of branch coverage (in seconds) for four variations of the JS test generation framework}
  \label{tbl.stats}
    \scriptsize
    \begin{tabular}{lc|ccc|ccc|ccc|ccc|ccc}
      \toprule
      \multirow{2}{*}{\textbf{NAME}} & \multirow{2}{*}{\textbf{\#D}}         &  \multicolumn{3}{c|}{$m_r$} & \multicolumn{3}{c|}{$m_g$} & \multicolumn{3}{c|}{$m_{g10}$} & \multirow{2}{*}{$\frac{t_r}{t_g}$} &  \multirow{2}{*}{$\frac{t_r}{t_{g10}}$} & \multirow{2}{*}{$\frac{t_g}{t_{g10}}$}   & \multirow{2}{*}{$a_{rg}$} &  \multirow{2}{*}{$a_{rg10}$} & \multirow{2}{*}{$a_{gg10}$} \\
      \cline{3-11}
            &                & $i$      & $t$  & $t/i$     & $i$& $t$&$t/i$             &$i$ &$t$ &$t/i$               &      &       &        &      &       &      \\
      \toprule
    \multicolumn{2}{l|}{\textbf{helpMe}*}     
                                 & 218      & 270  & 1.24      & 61 & 47 & 0.77             & 62 & 56 & 0.9                & 5.74 & 4.82  & 0.84   &      &      &       \\
    $(3,4,\inFor)$    & 1        & 4        & 4    & 1         & 5  & 3  & 0.6              & 8  & 6  & 0.75               & 1.33 & 0.67  & 0.5    & 0.57 & 0.39 & 0.37  \\
    $(5,6,\thenBr)$   & 2        & 4        & 5    & 1.25      & 8  & 6  & 0.75             & 7  & 5  & 0.71               & 0.83 & 1     & 1.2    & 0.46 & 0.5  & 0.53  \\
    $(5,15,\elseBr)$  & 2        & 121      & 156  & 1.29      & 24 & 21 & 0.86             & 23 & 24 & 1.04               & 7.43 & 6.5   & 0.88   & 0.87 & 0.86 & 0.48  \\
    $(9,10,\thenBr)$  & 3        & 85       & 101  & 1.19      & 18 & 14 & 0.78             & 19 & 17 & 0.89               & 7.21 & 5.94  & 0.82   & 0.98 & 0.95 & 0.40  \\
    $(9,14,\elseBr)$  & 3        & 4        & 4    & 1         & 6  & 4  & 0.67             & 5  & 4  & 0.8                & 1    & 1     & 1      & 0.56 & 0.51 & 0.45  \\
    \hline                                                                                                          
\multicolumn{2}{l|}{\textbf{isGameFinished}*} 
                                 & 264      & 220  & 0.83      & 32 & 30 & 0.94             & 43 & 43 & 1                  & 7.33 & 5.12  & 0.7    &      &      &        \\
    $(7,8,\thenBr)$   & 2        & 37       & 30   & 0.81      & 8  & 8  & 1                & 12 & 13 & 1.08               & 3.75 & 2.31  & 0.62   & 0.6  & 0.66 & 0.43   \\
    $(10,11,\thenBr)$ & 3        & \un{200} & 167  & 0.84      & 11 & 10 & 0.91             & 10 & 11 & 1.1                & 16.7 & 15.18 & 0.91   & 0.88 & 0.96 & 0.48   \\
    $(10,14,\elseBr)$ & 3        & 25       & 21   & 0.84      & 11 & 11 & 1                & 19 & 18 & 0.95               & 1.91 & 1.17  & 0.61   & 0.55 & 0.55 & 0.46   \\
    \hline
    \multicolumn{2}{l|}{\textbf{newGame}*}   
                                 & 18       & 14   & 0.78      & 11 & 9  & 0.81             & 10 & 10 & 1                  & 1.56 & 1.4   & 0.9    &      &      &      \\
    $(6,7,\thenBr)$   & 2        & 16       & 12   & 0.75      & 9  & 7  & 0.78             & 8  & 8  & 1                  & 1.71 & 1.5   & 0.88   & 0.64 & 0.65 & 0.5  \\
    \hline
    \multicolumn{2}{l|}{\textbf{revealAll}*}  
                                 & 60       & 50   & 0.83      & 44 & 44 & 1                & 47 & 53 & 1.13               & 1.14 & 0.94  & 0.83   &      &      &        \\
    $(2,3,\inFor)$    & 1        & 25       & 20   & 0.8       & 24 & 24 & 1                & 24 & 27 & 1.13               & 0.83 & 0.74  & 0.89   & 0.45 & 0.39 &  0.43  \\
    $(4,5,\inFor)$    & 2        & 35       & 30   & 0.86      & 20 & 20 & 1                & 23 & 26 & 1.13               & 1.5  & 1.15  & 0.77   & 0.62 & 0.55 &  0.37  \\
    \hline
\multicolumn{2}{l|}{\textbf{shuffleBoard}*}   
                                 & 15       & 29   & 1.93      & 15 & 26 & 1.73             & 17 & 29 & 1.71               & 1.12 & 1     & 0.9    &      &      &       \\
    $(13,14,\thenBr)$ & 3        & 5        & 10   & 2         & 5  & 9  & 1.8              & 6  & 10 & 1.67               & 1.11 & 1     & 0.9    & 0.58 & 0.53 & 0.46  \\
    $(17,18,\thenBr)$ & 3        & 5        & 10   & 2         & 5  & 10 & 2                & 6  & 11 & 1.83               & 1    & 0.91  & 0.91   & 0.46 & 0.47 & 0.5   \\
    \toprule
\multicolumn{2}{l|}{\textbf{toggleInfo}*}     
                                 & 6        & 6    & 1         & 7  & 7 & 1                 & 9 & 6   & 0.66               & 0.86  & 1     & 1.17  &    &      &       \\
    $(2,3,\thenBr)$   & 1        & 2        & 2    & 1         & 2  & 2 & 1                 & 2 & 1   & 0.5                & 1     & 2     & 2     & 0.54 & 0.58 & 0.55  \\
    $(6,7,\thenBr)$   & 1        & 2        & 2    & 1         & 3  & 3 & 1                 & 5 & 3   & 0.6                & 0.67  & 0.67  & 1     & 0.37 & 0.36 & 0.48  \\
    \toprule
\multicolumn{2}{l|}{\textbf{isValidCard}}        
                                 & 1001     & 514  & 0.51      & 21 & 8 & 0.38              & 21 & 10 & 0.48               & 64.25 & 51.4  & 0.8    &   &   &       \\
    $(3,6,\elseBr)$   & 1        & \un{200} & 103  & 0.52      & 4  & 2 & 0.5               & 4  & 2  & 0.5                & 51.5  & 51.5  & 1      & 1 & 1 & 0.5   \\
    $(7,8,\inFor)$    & 1        & \un{200} & 103  & 0.52      & 4  & 1 & 0.25              & 4  & 2  & 0.5                & 103   & 51.5  & 0.5    & 1 & 1 & 0.43  \\
    $(10,11,\thenBr)$ & 2        & \un{200} & 102  & 0.51      & 4  & 2 & 0.5               & 4  & 2  & 0.5                & 51    & 51    & 1      & 1 & 1 & 0.43  \\
    $(10,13,\elseBr)$ & 2        & \un{200} & 106  & 0.53      & 4  & 1 & 0.25              & 4  & 2  & 0.5                & 106   & 53    & 0.5    & 1 & 1 & 0.38  \\
    $(14,15,\inFor)$  & 1        & \un{200} & 100  & 0.5       & 4  & 2 & 0.5               & 4  & 2  & 0.5                & 50    & 50    & 1      & 1 & 1 & 0.55  \\
    \hline
\multicolumn{2}{l|}{\textbf{isValidVISA}}        
                                 & 201      & 95   & 0.47      & 8  & 3 & 0.38              & 8  & 2  & 0.25               & 31.67 & 47.5  & 1.5    &   &   &       \\
    $(2,3,\thenBr)$   & 1        & \un{200} & 95   & 0.48      & 7  & 3 & 0.43              & 7  & 2  & 0.29               & 31.67 & 47.5  & 1.5    & 1 & 1 & 0.59  \\
    \toprule
\multicolumn{2}{l|}{\textbf{initShields}*}    
                                 & 6        & 5    & 0.83      & 6  & 5 & 0.83              & 6  & 3  & 0.5                & 1      & 1.67 & 1.67   &      &      &       \\
    $(2,3,\inFor)$    & 1        & 6        & 5    & 0.83      & 6  & 4 & 0.67              & 6  & 3  & 0.5                & 1.25   & 1.67 & 1.33   & 0.83 & 0.84 & 0.53  \\
    \toprule
\multicolumn{2}{l|}{\textbf{brickJiggler}*}   
                                 & 7        & 8    & 1.14      & 6  & 4 & 0.67              & 4  & 3  & 0.75               & 2      & 2.67 & 1.33   &      &      &       \\
    $(2,3,\thenBr)$   & 1        & 6        & 7    & 1.17      & 5  & 3 & 0.6               & 3  & 2  & 0.67               & 2.33   & 3.5  & 1.5    & 0.83 & 0.85 & 0.56  \\
    \hline
\multicolumn{2}{l|}{\textbf{doPaddlePower}*}  
                                 & 19       & 15   & 0.79      & 204  & 140 & 0.69          & 25 & 16  & 0.64              & 0.11   & 0.94 & 8.75   &       &      &      \\
    $(10,11,\thenBr)$ & 1        & 16       & 12   & 0.75      & \un{200} & 136 & 0.68      & 22 & 13  & 0.59              & 0.09   & 0.92 & 10.46  &  0.02 & 0.43 & 0.94 \\
    \hline
\multicolumn{2}{l|}{\textbf{initBricks}*}     
                                 & 1418     & 2379 & 1.68      & 593  & 474 & 0.8           & 422 & 415 & 0.98             & 5.02   & 5.73  & 1.14   &      &      &       \\
    $(6,7,\thenBr)$   & 1        & 2        & 3    & 1.5       & 5    & 4   & 0.8           & 3   & 3   & 1                & 0.75   & 1     & 1.33   & 0.53 & 0.5  & 0.5   \\
    $(6,10,\elseBr)$  & 1        & 15       & 23   & 1.53      & 6    & 6   & 1             & 6   & 6   & 1                & 3.83   & 3.83  & 1      & 0.87 & 0.83 & 0.4   \\
    $(11,12,\thenBr)$ & 2        & \un{200} & 317  & 1.59      & 14   & 12  & 0.86          & 17  & 15  & 0.88             & 26.41  & 21.13 & 0.8    & 0.93 & 0.91 & 0.41  \\
    $(11,15,\elseBr)$ & 2        & 18       & 30   & 1.67      & 6    & 6   & 1             & 6   & 6   & 1                & 5      & 5     & 1      & 0.89 & 0.86 & 0.47  \\
    $(16,17,\thenBr)$ & 3        & \un{200} & 324  & 1.62      & 17   & 14  & 0.82          & 17  & 16  & 0.94             & 23.14  & 20.25 & 0.88   & 0.96 & 0.96 & 0.45  \\
    $(16,20,\elseBr)$ & 3        & 25       & 40   & 1.6       & 7    & 7   & 1             & 8   & 7   & 0.88             & 5.71   & 5.71  & 1      & 0.89 & 0.86 & 0.46  \\
    $(21,22,\thenBr)$ & 4        & \un{200} & 310  & 1.55      & 14   & 13  & 0.93          & 17  & 17  & 1                & 23.85  & 18.24 & 0.76   & 0.94 & 0.9  & 0.36  \\
    $(21,25,\elseBr)$ & 4        & 26       & 41   & 1.58      & 7    & 7   & 1             & 8   & 7   & 0.88             & 5.86   & 5.86  & 1      & 0.94 & 0.87 & 0.42  \\
    $(29,30,\thenBr)$ & 1        & \un{200} & 330  & 1.65      & 66   & 58  & 0.88          & 74  & 70  & 0.95             & 5.69   & 4.71  & 0.83   & 0.82 & 0.88 & 0.5   \\
    $(29,37,\elseBr)$ & 1        & 2        & 4    & 2         & 3    & 3   & 1             & 3   & 4   & 1.33             & 1.33   & 1     & 0.75   & 0.63 & 0.53 & 0.43  \\
    $(38,39,\thenBr)$ & 2        & 185      & 328  & 1.77      & 85   & 67  & 0.79          & 48  & 44  & 0.92             & 4.9    & 7.45  & 1.52   & 0.87 & 0.88 & 0.54  \\
    $(38,46,\elseBr)$ & 2        & 2        & 4    & 2         & 3    & 4   & 1.33          & 3   & 4   & 1.33             & 1      & 1     & 1      & 0.64 & 0.58 & 0.44  \\
    $(47,48,\thenBr)$ & 3        & 187      & 336  & 1.8       & \un{200} & 141 & 0.7       & 127 & 131 & 1.03             & 2.38   & 2.56  & 1.08   & 0.8  & 0.8  & 0.54  \\
    $(47,55,\elseBr)$ & 3        & 2        & 4    & 2         & 3    & 3   & 1             & 3   & 4   & 1.33             & 1.33   & 1     & 0.75   & 0.66 & 0.61 & 0.46  \\
    $(56,57,\thenBr)$ & 4        & 109      & 198  & 1.82      & 50   & 43  & 0.86          & 49  & 47  & 0.96             & 4.6    & 4.21  & 0.91   & 0.76 & 0.75 & 0.5   \\
    $(56,64,\elseBr)$ & 4        & 2        & 4    & 2         & 3    & 3   & 1             & 3   & 4   & 1.33             & 1.33   & 1     & 0.75   & 0.64 & 0.61 & 0.47  \\
    $(69,70,\thenBr)$ & 1        & 2        & 4    & 2         & 3    & 4   & 1.33          & 3   & 4   & 1.33             & 1      & 1     & 1      & 0.48 & 0.51 & 0.53  \\
    $(69,71,\elseBr)$ & 1        & 41       & 81   & 1.98      & 95   & 84  & 0.88          & 27  & 26  & 0.96             & 0.96   & 3.12  & 3.23   & 0.57 & 0.68 & 0.61  \\
    \toprule
    \multicolumn{2}{l|}{\textbf{do\_draw}}       
                                 & 268      & 625  & 2.33      & 383  & 1295 & 3.38         & 124 & 334 & 2.69             & 0.48   & 1.87  & 3.88   &      &      &       \\
    $(6,7,\thenBr)$   & 1        & 8        & 19   & 2.38      & 6    & 25   & 4.1          & 7   & 20  & 2.86             & 0.76   & 0.95  & 1.25   & 0.41 & 0.5  &  0.62 \\
    $(8,9,\thenBr)$   & 2        & 10       & 23   & 2.3       & 6    & 17   & 2.83         & 7   & 21  & 3                & 1.35   & 1.1   & 0.81   & 0.63 & 0.62 &  0.49 \\
    $(8,11,\elseBr)$  & 2        & 144      & 343  & 2.39      & 17   & 51   & 3            & 19  & 57  & 3                & 6.73   & 6.02  & 0.89   & 0.91 & 0.91 &  0.46 \\
    $(44,45,\thenBr)$ & 1        & 57       & 144  & 2.5       & \un{200} & 681  & 3.4      & 40  & 111 & 2.78             & 0.21   & 1.3   & 6.14   & 0.16 & 0.58 &  0.89 \\
    $(48,49,\thenBr)$ & 1        & 26       & 68   & 2.61      & 137  & 492  & 3.59         & 34  & 97  & 2.85             & 0.14   & 0.7   & 5.07   & 0.24 & 0.4  &  0.74 \\
    \toprule
\multicolumn{2}{l|}{\textbf{prob\_gamma}}        
                                 & 2006     & 710  & 0.35      & 163 & 84   & 0.52          & 162 & 81  & 0.5              & 8.45   & 8.77  & 1.04   &  &   &        \\
    $(4,5,\thenBr)$   & 1        & \un{200} & 71   & 0.36      & 2   & 1    & 0.5           & 2   & 1   & 0.5              & 71     & 71    & 1      & 1 & 1 &  0.47  \\
    $(6,7,\thenBr)$   & 2        & \un{200} & 71   & 0.36      & 2   & 1    & 0.5           & 2   & 1   & 0.5              & 71     & 71    & 1      & 1 & 1 &  0.51  \\
    $(6,9,\elseBr)$   & 2        & \un{200} & 70   & 0.35      & 2   & 1    & 0.5           & 2   & 1   & 0.5              & 70     & 70    & 1      & 1 & 1 &  0.49  \\
    $(10,11,\thenBr)$ & 2        & \un{200} & 72   & 0.36      & 62  & 42   & 0.68          & 61  & 40  & 0.66             & 1.71   & 1.8   & 1.05   & 1 & 1 &  0.62  \\
    $(10,13,\elseBr)$ & 2        & \un{200} & 71   & 0.36      & 2   & 1    & 0.5           & 2   & 1   & 0.5              & 71     & 71    & 1      & 1 & 1 &  0.57  \\
    $(16,17,\inWhile)$& 2        & \un{200} & 70   & 0.35      & 2   & 1    & 0.5           & 2   & 1   & 0.5              & 70     & 70    & 1      & 1 & 1 &  0.53  \\
    $(20,21,\thenBr)$ & 2        & \un{200} & 70   & 0.35      & 6   & 2    & 0.33          & 6   & 3   & 0.5              & 35     & 23.33 & 0.67   & 1 & 1 & 0.48   \\
    $(20,23,\elseBr)$ & 2        & \un{200} & 72   & 0.36      & 2   & 1    & 0.5           & 2   & 1   & 0.5              & 72     & 72    & 1      & 1 & 1 &  0.49  \\
    $(30,31,\thenBr)$ & 1        & \un{200} & 72   & 0.36      & 53  & 23   & 0.43          & 52  & 22  & 0.42             & 3.13   & 3.27  & 1.05   & 1 & 1 &  0.58  \\
    $(34,35,\thenBr)$ & 1        & \un{200} & 72   & 0.36      & 24  & 10   & 0.42          & 25  & 10  & 0.4              & 7.2    & 7.2   & 1      & 1 & 1 &  0.51  \\
    \bottomrule
    \end{tabular}
\end{table}

\paragraph{\textbf{RQ1 (performance).}} We would like to study the performance of the three variations of the testing framework: Random ($R$), Genetic ($G$) and Genetic with Restart ($G10$). To address this question, we applied our framework to all branches of each function in Table~\ref{tbl.case.studies}. Due to the probabilistic nature of the test generation process, the experiments has to be repeated 50 times to get statistically significant results. Our discussion completely excludes some functions in Table~\ref{tbl.case.studies} ($-$ sign in the $?$ column) as not presenting real challenge. Despite of it apparent complexity, like the function \emph{update}, in practice both random and genetic testing strategies take maximum upto two seconds to cover each branch. This gave us in total 14 functions, for which we present summary of performance statistics in Table~\ref{tbl.stats} for all three testing strategy. For the sake of space, we omitted from that table the branches whose average coverage time was less than one second. Functions suffixed with the start (*) symbol indicate reference to DOM.  Column $D$ next to the branch shows its depth. We computed the following medians for each algorithm: the number of iterations ($i$), time in seconds ($t$), and their ratio ($t/i$). In the table, these values are grouped into three columns $m_r$, $m_g$ and $m_{g10}$, one per algorithm type $R$, $G$ and $G5$  respectively. Next group of columns $t_r/t_g$, $t_r/t_{g10}$ and $t_g/t_{g10}$ measures the relative performance of each pair of the testing strategies $(R,G)$, $(R,G10)$, and $(G,G10)$ respectively.

The fact that the median of generation reached the upper limit of \underline{200} means the branch was never covered. With that budget in mind not all algorithms were always performing successfully. The main reason for the random generation to fail, e.g. the \emph{(10,11,then)} branch of the \emph{isGameFinished} function or any branch of the \emph{isValidCard} function, is the huge size of the search space and complete absence of any guidance. On the contrary, the genetic search may stuck on a flat space when the fitness function does not carry any information how to get out it, e.g. the branches \emph{(10,11,then)}, \emph{(40,48,then)} and \emph{(40,45,then)} of the functions \emph{doPaddlePower}, \emph{initBricks} and \emph{do_draw} respectively. (say why random give better performance in that case) Those examples motivated us to introduce the genetic algorithm with restart ($G5$), which is as our evaluation demonstrated not only provided a solution within given budget, but also outperformed random search. (Maybe discuss examples where $R$ outperformed $G5$)

Table~\ref{tbl.stats} also shows accumulated statistics for each function as a whole (row in line with the function name). This gives us a way to compare  all three testing strategies with each other at the function level. Chart in Figure~\ref{fig.gen.time.comp} clearly illustrates how the median time varies per function for each algorithm. Across all 14 examples $G10$ indicated the best performance comparing to both $R$ and $G$. We observed only two cases (\emph{revealAll}) and (\emph{doPaddlePower}) where random testing gave a slightly better result by only 6\%. If we take in consideration only examples with the average execution time above 50 seconds, we can conclude that $G10$ was minimum 1.87 time (\emph{do_draw}) and maximum 51.4 (\emph{isValidCard}) time faster than $R$. At the same time, even plain genetic algorithm $G$ outperforms the random one $R$ in all examples except of two \emph{doPaddlePower} and \emph{initBricks} due to the reasons discussed early in this section. In cases of success, especially for some small examples such as \emph{newGame} and \emph{isValidCard}, the genetic algorithm was even able to beat $G5$ by upto 30\%.  

\paragraph{\textbf{RQ2 (cost).}} The cost of one test iteration is defined as the relation between the execution time and the number of generations, i.e. $t/i$ in Table~\ref{tbl.stats}. Figure~\ref{fig.get.cost} shows the comparison of various algorithms across all case-studies. 


\paragraph{\textbf{RQ3 (coverage).}} ...

\begin{figure}[t]
  \centering
  \begin{tikzpicture}[scale=0.8]
    \begin{axis}[
        every axis plot post/.style={/pgf/number format/fixed},
        ybar,
        ymin=0,ymax=950,
        width=11cm,height=3.3cm,
        bar width=3pt,
        enlarge x limits=0.05,
        legend style={at={(0.05,1.1)},anchor=north west,font=\footnotesize,legend columns=-1},
        legend cell align={left},
        ylabel={time (sec.)},
        symbolic x coords={helpMe*,isGameFinished*,newGame*,revealAll*,shuffleBoard*,toggleInfo*,isValidCard,isValidVISA,initShields*,brickJiggler*,doPaddlePower*,initBricks*,do\_draw,prob\_gamma},
        xtick=data,
        restrict y to domain*=0:1350, % Cut values off at 14
        visualization depends on=rawy\as\rawy, % Save the unclipped values
        after end axis/.code={ % Draw line indicating break
          \draw [ultra thick, white, decoration={snake, amplitude=1pt}, decorate] (rel axis cs:0,1.05) -- (rel axis cs:1,1.05);
        },
        nodes near coords={%
          \pgfmathprintnumber{\rawy}% Print unclipped values
        },
        every node near coord/.append style={rotate=90,anchor=west,font=\footnotesize},
        % every node near coord/.append style={font=\footnotesize},
        axis lines*=left,
        clip=false,
        x tick label style={rotate=45,anchor=east,font=\footnotesize\bfseries},
        y tick label style={font=\footnotesize}
      ]
      \addplot[fill=blue] coordinates {(helpMe*,270) (isGameFinished*,220) (newGame*,14) (revealAll*,50) (shuffleBoard*,29) (toggleInfo*,6) (isValidCard,514) (isValidVISA,95) (initShields*,5) (brickJiggler*,8) (doPaddlePower*,15)  (initBricks*,2379) (do\_draw,625) (prob\_gamma,710)};
      \addplot[fill=red] coordinates {(helpMe*,47)  (isGameFinished*,30)  (newGame*,9)  (revealAll*,44) (shuffleBoard*,26) (toggleInfo*,7) (isValidCard,8)   (isValidVISA,3)  (initShields*,5) (brickJiggler*,4) (doPaddlePower*,140) (initBricks*,474) (do\_draw,1295) (prob\_gamma,84)};
      \addplot[fill=yellow] coordinates {(helpMe*,56)  (isGameFinished*,43)  (newGame*,10) (revealAll*,53) (shuffleBoard*,29) (toggleInfo*,6) (isValidCard,10)  (isValidVISA,2)  (initShields*,3) (brickJiggler*,3) (doPaddlePower*,16) (initBricks*,415) (do\_draw,334) (prob\_gamma,81)}; 
      \legend{R,G,G10}
    \end{axis}
  \end{tikzpicture}
  \caption{Overall test generation time per function.}
  \label{fig.gen.time.comp}
\end{figure}

% \input{summary_statistics}

\begin{figure}[t]
  \begin{tikzpicture}[scale=0.8]
    \begin{axis}[
        every axis plot post/.style={/pgf/number format/fixed},
        ybar,
        ymin=0,ymax=4,
        width=11cm,height=3.3cm,
        bar width=3pt,
        enlarge x limits=0.05,
        legend style={at={(0.05,1.2)},anchor=north west,font=\footnotesize,legend columns=-1},
        legend cell align={left},
        ylabel={time (sec.)},
        symbolic x coords={helpMe*,isGameFinished*,newGame*,revealAll*,shuffleBoard*,toggleInfo*,isValidCard,isValidVISA,initShields*,brickJiggler*,doPaddlePower*,initBricks*,do\_draw,prob\_gamma},
        xtick=data,
        nodes near coords,
        every node near coord/.append style={rotate=90, anchor=west, font=\footnotesize},
        % every node near coord/.append style={font=\footnotesize},
        axis lines*=left,
        clip=false,
        x tick label style={rotate=45,anchor=east,font=\footnotesize\bfseries},
        y tick label style={font=\footnotesize}
      ]
      \addplot[fill=blue] coordinates {(helpMe*,1.24) (isGameFinished*,0.83) (newGame*,0.78) (revealAll*,0.83) (shuffleBoard*,1.93) (toggleInfo*,1) (isValidCard,0.51) (isValidVISA,0.47) (initShields*,0.83) (brickJiggler*,1.14) (doPaddlePower*,0.79)  (initBricks*,1.68) (do\_draw,2.33) (prob\_gamma,0.35)};
      \addplot[fill=red] coordinates {(helpMe*,0.77)  (isGameFinished*,0.94)  (newGame*,0.81)  (revealAll*,1) (shuffleBoard*,1.73) (toggleInfo*,1) (isValidCard,0.38)   (isValidVISA,0.38)  (initShields*,0.83) (brickJiggler*,0.67) (doPaddlePower*,0.69) (initBricks*,0.8) (do\_draw,3.38) (prob\_gamma,0.52)};
      \addplot[fill=yellow] coordinates {(helpMe*,0.9)  (isGameFinished*,1)  (newGame*,1) (revealAll*,1.13) (shuffleBoard*,1.71) (toggleInfo*,0.66) (isValidCard,0.48)  (isValidVISA,0.25)  (initShields*,0.5) (brickJiggler*,0.75) (doPaddlePower*,0.64) (initBricks*,0.98) (do\_draw,2.69) (prob\_gamma,0.5)}; 
      \legend{R,G,G10}
    \end{axis}
  \end{tikzpicture}
  \caption{Speed of test generation measured as $t/i$}
    \label{fig.get.cost}
\end{figure}


\begin{figure}[t]
  \begin{tikzpicture}[scale=0.8]
    \begin{axis}[
        every axis plot post/.style={/pgf/number format/fixed},
        ybar,
        ymin=0,ymax=135,
        width=11cm,height=3.3cm,
        bar width=3pt,
        enlarge x limits=0.05,
        legend style={at={(0.05,1.2)},anchor=north west,font=\footnotesize,legend columns=-1},
        legend cell align={left},
        ylabel={time (sec.)},
        symbolic x coords={helpMe*,isGameFinished*,newGame*,revealAll*,shuffleBoard*,toggleInfo*,isValidCard,isValidVISA,initShields*,brickJiggler*,doPaddlePower*,initBricks*,do\_draw,prob\_gamma},
        xtick=data,
        nodes near coords,
        every node near coord/.append style={rotate=90, anchor=west, font=\footnotesize},
        % every node near coord/.append style={font=\footnotesize},
        axis lines*=left,
        clip=false,
        x tick label style={rotate=45,anchor=east,font=\footnotesize\bfseries},
        y tick label style={font=\footnotesize}
      ]
      \addplot[fill=blue] coordinates {(helpMe*,54) (isGameFinished*,44) (newGame*,4.7) (revealAll*,25) (shuffleBoard*,3.6) (toggleInfo*,1.5) (isValidCard,85.7) (isValidVISA,47.5) (initShields*,5) (brickJiggler*,4) (doPaddlePower*,3.75)  (initBricks*,132.16) (do\_draw,28.5) (prob\_gamma,44.4)};
      
      \addplot[fill=red] coordinates {(helpMe*,9.4)  (isGameFinished*,6)  (newGame*,3)  (revealAll*,22) (shuffleBoard*,3.25) (toggleInfo*,1.75) (isValidCard,1.33)   (isValidVISA,1.5)  (initShields*,4) (brickJiggler*,2) (doPaddlePower*,35) (initBricks*,26.33) (do\_draw,58.9) (prob\_gamma,5.25)};
      
      \addplot[fill=yellow] coordinates {(helpMe*,11.2)  (isGameFinished*,8.6)  (newGame*,3.3) (revealAll*,26.5) (shuffleBoard*,3.6) (toggleInfo*,1.5) (isValidCard,1.66)  (isValidVISA,1)  (initShields*,3) (brickJiggler*,1.5) (doPaddlePower*,4) (initBricks*,23.1) (do\_draw,15.18) (prob\_gamma,5.1)}; 
      \legend{R,G,G10}
    \end{axis}
  \end{tikzpicture}
  \caption{Average generation time per branch}
    \label{fig:1}
\end{figure}


\begin{figure}[!t]
  \begin{tikzpicture}[scale=0.5]
    \begin{axis}[
        xlabel={Time budget per branch (seconds)},
        ylabel={Number of covered branches},
        xmin=0, xmax=150,
        ymin=0, ymax=59,
        xtick={0,5,10,30,60,90,120,150,180},
        ytick={0,10,20,30,40,50},
        legend pos=south east,
        ymajorgrids=true,
        grid style=dashed,
      ]
      
      \addplot[
        color=blue,
        mark=square*,
      ] coordinates {
        (5,13) (10,15) (30,25) (60,28) (90,29) (120,30) (150,31)
      }; 
      \addplot[
        color=red,
        mark=triangle*,
      ]  coordinates {
        (5,27) (10,37) (30,48) (60,52) (90,54) (120,54) (150,54)
      };
      \addplot[
        color=yellow,
        mark=*,
      ]   coordinates {
        (5,27) (10,35) (30,50) (60,54) (90,55) (120,56) (150,59)
      };
      \legend{R,G,G10}
 
    \end{axis}
  \end{tikzpicture}
  \caption{Progress of the branch coverage given fix time budget per branch}
    \label{fig:2}
\end{figure}


\section{Discussion}
\label{sec.disc}

\subsection{Limitations}
\label{sub.sec.eval.limit}

Our framework imposes certain constraints on the structure of JS programs:
\begin{itemize}
\item no inter-procedural function calls
\item no recursion  
\end{itemize}


\subsection{Threats to Validity}
\label{sub.sec.thhreats}

%% --------------------------------------------------------------------
\section{Related Work}
\label{sec:related.work}
%% --------------------------------------------------------------------

\subsection{Search-Based Test Case Generation}
\label{sub.sec.search.based}

\cite{wegener2001evolutionary} evolutionary test generation for structural coverage.

\cite{tonella2004evolutionary} evolutionary testing of classes

\cite{wappler2005using} evolutionary testing of object-oriented software.

\cite{wappler2006evolutionary} uses strongly-typed genetic programming and deals with the runtime exceptions.

\cite{lakhotia2007multi} multi-objective search-based test data generation 

\cite{cao2009search} multi-path search-based test data generation

\cite{awedikian2009mc} MC/DC test input generation 

\cite{shahbazi2016black} generation of string test data

\cite{fraser2012mutation} mutation-driven generation of unit tests and oracles

\cite{havrikov2014xmlmate} XMLMate: evolutionary XML test generation.

\cite{mcminn2004search} seminal survey of search-based test data generation techniques.

\cite{mcminn2011search} recent overview of search-based testing.

\cite{mairhofer2011search} search-based testing for dynamic languages (Ruby)

\cite{baars2011symbolic} combines dynamic analysis with symbolic information to improve search-based testing

\cite{alshahwan2011automated} automated web application testing using search based software techniques.

\cite{ma2015grt} guided random testing

\cite{mao2016sapienz} Multi-objective automated testing for Android application

\subsection{Static and Dynamic Analysis of JavaScript}
\label{sub.sec.js.static.anal}

Static analysis is a powerful technique commonly used as solid alternative for program testing. In fact both techniques can benefit from one another. For such weakly typed and dynamic languages as JavaScript employing static analysis to infer types can be an invaluable source of information to identify potential bugs or even guarantee their absence. Jensen et al.~\cite{tajs2009} presented such an analysis for JavaScript using abstract interpretation. In the follow-up work~\cite{dom2011} they extended the analysis with the abstractions to reason about HTML DOM and browser API. Given step let the authors to carry static analysis at the level of complete web application (JavaScript + HTML).
\cite{jquery2014}


ACTARUS is a static taint analysis of JS\cite{guarnieri2011saving}.

Jalangi is dynamic analysis framework for JavaScript \cite{sen2013jalangi}.

Dynamic type inconsistency analysis (implemented on top Jalangi) for JavaScript\cite{pradel2015typedevil}.

Salable dynamic analysis framework for JS based on shadow executions~\cite{create.citation}.

Information-flow security for JS~\cite{hedin2012information}.

\subsection{Whole Web Application Testing}
\label{sub.sec.web.app.test}

Artemis~\cite{artemis2011} is a feedback-directed random testing tool for JavaScript web application. It discoverers new tests by generating sequences of executable events and monitoring they effect on the state of the application. \cite{ail2013}

Testing of AJAX application by means of crawling of the application to infer state-flow graph~\cite{mesbah2012crawling} ATUSA ~\cite{mesbah2012invariant}

Learning DOM invariants from multiple executions of the application~\cite{pattabiraman2010dodom}.

Measuring test adequacy for web application based on the DOM state coverage~\cite{mirzaaghaei2014dom}.

Combining human written test cases with the automatically generated once by crawling in order to extend test coverage~\cite{milani2014leveraging}.

DOM-aware JavaScript code completion~\cite{bajaj2014dompletion}. 

\subsection{Formal Techniques}
\label{sub.sec.formal}

Modeling and reasoning about DOM events~\cite{lerner2012modeling}.

\subsection{JavaScript Unit Testing}
\label{sub.sec.js.unit.test}

Generating fixture for JavaScript unit tests by means of concolic execution~\cite{amin:ase15}. Inference of UI oracles to complement JS unit tests~\cite{icst16}.

JS unit test generation by means of symbolic execution~\cite{tanida2014automatic}.

Flycatcher~\cite{deautomatic}

\subsection{Misc JavaScript Testing Techniques}
\label{sub.sec.misc.test.tech}

Discover patterns from bug fixes and imposing them as potential bugs in the future~\cite{quinn:fse16}. 

\section{Conclusions}
\label{sec:concl}
1 page.

\bibliographystyle{ACM-Reference-Format}
\bibliography{icse2018.bib} 


\end{document}
